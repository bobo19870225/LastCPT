Index: app/src/main/java/www/jingkan/com/view/ChooseCalibrationTypeActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/ChooseCalibrationTypeActivity.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/ChooseCalibrationTypeActivity.java	(date 1577155276000)
@@ -4,6 +4,8 @@
 
 package www.jingkan.com.view;
 
+import android.view.View;
+
 import www.jingkan.com.R;
 import www.jingkan.com.view.base.BaseActivity;
 
@@ -15,22 +17,45 @@
 public class ChooseCalibrationTypeActivity extends BaseActivity {
 
     private String[] strings;
+    private boolean isDouble;
 
     @Override
     protected void setView() {
         strings = (String[]) mData;
         setToolBar(strings[1]);
-        findViewById(R.id.rl_qc).setOnClickListener(v -> {
-            strings[1] = "双桥锥头标定";
+        View rlQc = findViewById(R.id.rl_qc);
+        View rlFs = findViewById(R.id.rl_fs);
+        View rlFa = findViewById(R.id.rl_fa);
+        if (strings[1].contains("双桥")) {
+            isDouble = true;
+            rlFs.setVisibility(View.VISIBLE);
+        } else {
+            isDouble = false;
+            rlFs.setVisibility(View.GONE);
+        }
+        if (strings[1].contains("多功能")) {
+            rlFa.setVisibility(View.VISIBLE);
+        } else {
+            rlFa.setVisibility(View.GONE);
+        }
+        rlQc.setOnClickListener(v -> {
+            if (isDouble) {
+                strings[1] = "双桥锥头标定";
+            } else {
+                strings[1] = "单桥锥头标定";
+            }
+
             goTo(CalibrationParameterActivity.class, strings);
         });
 
-
-        findViewById(R.id.rl_fs).setOnClickListener(v -> {
+        rlFs.setOnClickListener(v -> {
             strings[1] = "双桥侧壁标定";
             goTo(CalibrationParameterActivity.class, strings);
         });
-
+        rlFa.setOnClickListener(v -> {
+            strings[1] = "斜度标定";
+            goTo(CalibrationParameterActivity.class, strings);
+        });
     }
 
     @Override
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/SimpleSeriesRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/SimpleSeriesRenderer.java	(date 1580280153000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/SimpleSeriesRenderer.java	(date 1580280153000)
@@ -0,0 +1,108 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.renderer;
+
+import java.io.Serializable;
+import java.text.NumberFormat;
+
+public class SimpleSeriesRenderer implements Serializable {
+    private int mColor = -16776961;
+    private BasicStroke mStroke;
+    private boolean mGradientEnabled = false;
+    private double mGradientStartValue;
+    private int mGradientStartColor;
+    private double mGradientStopValue;
+    private int mGradientStopColor;
+    private boolean mShowLegendItem = true;
+    private boolean mHighlighted;
+    private boolean mDisplayBoundingPoints = true;
+    private NumberFormat mChartValuesFormat;
+
+    public SimpleSeriesRenderer() {
+    }
+
+    public int getColor() {
+        return this.mColor;
+    }
+
+    public void setColor(int color) {
+        this.mColor = color;
+    }
+
+    public BasicStroke getStroke() {
+        return this.mStroke;
+    }
+
+    public void setStroke(BasicStroke stroke) {
+        this.mStroke = stroke;
+    }
+
+    public boolean isGradientEnabled() {
+        return this.mGradientEnabled;
+    }
+
+    public void setGradientEnabled(boolean enabled) {
+        this.mGradientEnabled = enabled;
+    }
+
+    public double getGradientStartValue() {
+        return this.mGradientStartValue;
+    }
+
+    public int getGradientStartColor() {
+        return this.mGradientStartColor;
+    }
+
+    public void setGradientStart(double start, int color) {
+        this.mGradientStartValue = start;
+        this.mGradientStartColor = color;
+    }
+
+    public double getGradientStopValue() {
+        return this.mGradientStopValue;
+    }
+
+    public int getGradientStopColor() {
+        return this.mGradientStopColor;
+    }
+
+    public void setGradientStop(double start, int color) {
+        this.mGradientStopValue = start;
+        this.mGradientStopColor = color;
+    }
+
+    public boolean isShowLegendItem() {
+        return this.mShowLegendItem;
+    }
+
+    public void setShowLegendItem(boolean showLegend) {
+        this.mShowLegendItem = showLegend;
+    }
+
+    public boolean isHighlighted() {
+        return this.mHighlighted;
+    }
+
+    public void setHighlighted(boolean highlighted) {
+        this.mHighlighted = highlighted;
+    }
+
+    public boolean isDisplayBoundingPoints() {
+        return this.mDisplayBoundingPoints;
+    }
+
+    public void setDisplayBoundingPoints(boolean display) {
+        this.mDisplayBoundingPoints = display;
+    }
+
+    public NumberFormat getChartValuesFormat() {
+        return this.mChartValuesFormat;
+    }
+
+    public void setChartValuesFormat(NumberFormat format) {
+        this.mChartValuesFormat = format;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/XYSeriesRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/XYSeriesRenderer.java	(date 1580289897000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/XYSeriesRenderer.java	(date 1580289897000)
@@ -0,0 +1,223 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.renderer;
+
+import android.graphics.Color;
+import android.graphics.Paint.Align;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.chart.PointStyle;
+
+public class XYSeriesRenderer extends SimpleSeriesRenderer {
+    private boolean mFillPoints = false;
+    private List<XYSeriesRenderer.FillOutsideLine> mFillBelowLine = new ArrayList();
+    private PointStyle mPointStyle;
+    private float mPointStrokeWidth;
+    private float mLineWidth;
+    private boolean mDisplayChartValues;
+    private int mDisplayChartValuesDistance;
+    private float mChartValuesTextSize;
+    private Align mChartValuesTextAlign;
+    private float mChartValuesSpacing;
+    private float mAnnotationsTextSize;
+    private Align mAnnotationsTextAlign;
+    private int mAnnotationsColor;
+
+    public XYSeriesRenderer() {
+        this.mPointStyle = PointStyle.POINT;
+        this.mPointStrokeWidth = 1.0F;
+        this.mLineWidth = 1.0F;
+        this.mDisplayChartValuesDistance = 100;
+        this.mChartValuesTextSize = 10.0F;
+        this.mChartValuesTextAlign = Align.CENTER;
+        this.mChartValuesSpacing = 5.0F;
+        this.mAnnotationsTextSize = 10.0F;
+        this.mAnnotationsTextAlign = Align.CENTER;
+        this.mAnnotationsColor = -3355444;
+    }
+
+    /**
+     * @deprecated
+     */
+    @Deprecated
+    public boolean isFillBelowLine() {
+        return this.mFillBelowLine.size() > 0;
+    }
+
+    /**
+     * @deprecated
+     */
+    @Deprecated
+    public void setFillBelowLine(boolean fill) {
+        this.mFillBelowLine.clear();
+        if (fill) {
+            this.mFillBelowLine.add(new XYSeriesRenderer.FillOutsideLine(XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_ALL));
+        } else {
+            this.mFillBelowLine.add(new XYSeriesRenderer.FillOutsideLine(XYSeriesRenderer.FillOutsideLine.Type.NONE));
+        }
+
+    }
+
+    public XYSeriesRenderer.FillOutsideLine[] getFillOutsideLine() {
+        return (XYSeriesRenderer.FillOutsideLine[]) this.mFillBelowLine.toArray(new XYSeriesRenderer.FillOutsideLine[0]);
+    }
+
+    public void addFillOutsideLine(XYSeriesRenderer.FillOutsideLine fill) {
+        this.mFillBelowLine.add(fill);
+    }
+
+    public boolean isFillPoints() {
+        return this.mFillPoints;
+    }
+
+    public void setFillPoints(boolean fill) {
+        this.mFillPoints = fill;
+    }
+
+    /**
+     * @deprecated
+     */
+    @Deprecated
+    public void setFillBelowLineColor(int color) {
+        if (this.mFillBelowLine.size() > 0) {
+            ((XYSeriesRenderer.FillOutsideLine) this.mFillBelowLine.get(0)).setColor(color);
+        }
+
+    }
+
+    public PointStyle getPointStyle() {
+        return this.mPointStyle;
+    }
+
+    public void setPointStyle(PointStyle style) {
+        this.mPointStyle = style;
+    }
+
+    public float getPointStrokeWidth() {
+        return this.mPointStrokeWidth;
+    }
+
+    public void setPointStrokeWidth(float strokeWidth) {
+        this.mPointStrokeWidth = strokeWidth;
+    }
+
+    public float getLineWidth() {
+        return this.mLineWidth;
+    }
+
+    public void setLineWidth(float lineWidth) {
+        this.mLineWidth = lineWidth;
+    }
+
+    public boolean isDisplayChartValues() {
+        return this.mDisplayChartValues;
+    }
+
+    public void setDisplayChartValues(boolean display) {
+        this.mDisplayChartValues = display;
+    }
+
+    public int getDisplayChartValuesDistance() {
+        return this.mDisplayChartValuesDistance;
+    }
+
+    public void setDisplayChartValuesDistance(int distance) {
+        this.mDisplayChartValuesDistance = distance;
+    }
+
+    public float getChartValuesTextSize() {
+        return this.mChartValuesTextSize;
+    }
+
+    public void setChartValuesTextSize(float textSize) {
+        this.mChartValuesTextSize = textSize;
+    }
+
+    public Align getChartValuesTextAlign() {
+        return this.mChartValuesTextAlign;
+    }
+
+    public void setChartValuesTextAlign(Align align) {
+        this.mChartValuesTextAlign = align;
+    }
+
+    public float getChartValuesSpacing() {
+        return this.mChartValuesSpacing;
+    }
+
+    public void setChartValuesSpacing(float spacing) {
+        this.mChartValuesSpacing = spacing;
+    }
+
+    public float getAnnotationsTextSize() {
+        return this.mAnnotationsTextSize;
+    }
+
+    public void setAnnotationsTextSize(float textSize) {
+        this.mAnnotationsTextSize = textSize;
+    }
+
+    public Align getAnnotationsTextAlign() {
+        return this.mAnnotationsTextAlign;
+    }
+
+    public void setAnnotationsTextAlign(Align align) {
+        this.mAnnotationsTextAlign = align;
+    }
+
+    public int getAnnotationsColor() {
+        return this.mAnnotationsColor;
+    }
+
+    public void setAnnotationsColor(int color) {
+        this.mAnnotationsColor = color;
+    }
+
+    public static class FillOutsideLine implements Serializable {
+        private final XYSeriesRenderer.FillOutsideLine.Type mType;
+        private int mColor = Color.argb(125, 0, 0, 200);
+        private int[] mFillRange;
+
+        public FillOutsideLine(XYSeriesRenderer.FillOutsideLine.Type type) {
+            this.mType = type;
+        }
+
+        public int getColor() {
+            return this.mColor;
+        }
+
+        public void setColor(int color) {
+            this.mColor = color;
+        }
+
+        public XYSeriesRenderer.FillOutsideLine.Type getType() {
+            return this.mType;
+        }
+
+        public int[] getFillRange() {
+            return this.mFillRange;
+        }
+
+        public void setFillRange(int[] range) {
+            this.mFillRange = range;
+        }
+
+        public static enum Type {
+            NONE,
+            BOUNDS_ALL,
+            BOUNDS_BELOW,
+            BOUNDS_ABOVE,
+            BELOW,
+            ABOVE;
+
+            private Type() {
+            }
+        }
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/BasicStroke.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/BasicStroke.java	(date 1580280153000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/BasicStroke.java	(date 1580280153000)
@@ -0,0 +1,55 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.renderer;
+
+import android.graphics.Paint.Cap;
+import android.graphics.Paint.Join;
+
+import java.io.Serializable;
+
+public class BasicStroke implements Serializable {
+    public static final BasicStroke SOLID;
+    public static final BasicStroke DASHED;
+    public static final BasicStroke DOTTED;
+    private Cap mCap;
+    private Join mJoin;
+    private float mMiter;
+    private float[] mIntervals;
+    private float mPhase;
+
+    public BasicStroke(Cap cap, Join join, float miter, float[] intervals, float phase) {
+        this.mCap = cap;
+        this.mJoin = join;
+        this.mMiter = miter;
+        this.mIntervals = intervals;
+    }
+
+    public Cap getCap() {
+        return this.mCap;
+    }
+
+    public Join getJoin() {
+        return this.mJoin;
+    }
+
+    public float getMiter() {
+        return this.mMiter;
+    }
+
+    public float[] getIntervals() {
+        return this.mIntervals;
+    }
+
+    public float getPhase() {
+        return this.mPhase;
+    }
+
+    static {
+        SOLID = new BasicStroke(Cap.BUTT, Join.MITER, 4.0F, (float[]) null, 0.0F);
+        DASHED = new BasicStroke(Cap.ROUND, Join.BEVEL, 10.0F, new float[]{10.0F, 10.0F}, 1.0F);
+        DOTTED = new BasicStroke(Cap.ROUND, Join.BEVEL, 5.0F, new float[]{2.0F, 10.0F}, 1.0F);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/ChartFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/ChartFactory.java	(date 1580376426000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/ChartFactory.java	(date 1580376426000)
@@ -0,0 +1,256 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine;
+
+import android.content.Context;
+import android.content.Intent;
+
+import www.jingkan.com.view.chart.achartengine.chart.BarChart;
+import www.jingkan.com.view.chart.achartengine.chart.BubbleChart;
+import www.jingkan.com.view.chart.achartengine.chart.CombinedXYChart;
+import www.jingkan.com.view.chart.achartengine.chart.CubicLineChart;
+import www.jingkan.com.view.chart.achartengine.chart.DialChart;
+import www.jingkan.com.view.chart.achartengine.chart.DoughnutChart;
+import www.jingkan.com.view.chart.achartengine.chart.LineChart;
+import www.jingkan.com.view.chart.achartengine.chart.PieChart;
+import www.jingkan.com.view.chart.achartengine.chart.RangeBarChart;
+import www.jingkan.com.view.chart.achartengine.chart.ScatterChart;
+import www.jingkan.com.view.chart.achartengine.chart.TimeChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+import www.jingkan.com.view.chart.achartengine.model.CategorySeries;
+import www.jingkan.com.view.chart.achartengine.model.MultipleCategorySeries;
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.DialRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+
+public class ChartFactory {
+    public static final String CHART = "chart";
+    public static final String TITLE = "title";
+
+    private ChartFactory() {
+    }
+
+    public static final GraphicalView getLineChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        checkParameters(dataset, renderer);
+        XYChart chart = new LineChart(dataset, renderer);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getCubeLineChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, float smoothness) {
+        checkParameters(dataset, renderer);
+        XYChart chart = new CubicLineChart(dataset, renderer, smoothness);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getScatterChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        checkParameters(dataset, renderer);
+        XYChart chart = new ScatterChart(dataset, renderer);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getBubbleChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        checkParameters(dataset, renderer);
+        XYChart chart = new BubbleChart(dataset, renderer);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getTimeChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, String format) {
+        checkParameters(dataset, renderer);
+        TimeChart chart = new TimeChart(dataset, renderer);
+        chart.setDateFormat(format);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getBarChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, BarChart.Type type) {
+        checkParameters(dataset, renderer);
+        XYChart chart = new BarChart(dataset, renderer, type);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getRangeBarChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, BarChart.Type type) {
+        checkParameters(dataset, renderer);
+        XYChart chart = new RangeBarChart(dataset, renderer, type);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getCombinedXYChartView(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, CombinedXYChart.XYCombinedChartDef[] types) {
+        checkParameters(dataset, renderer);
+        CombinedXYChart chart = new CombinedXYChart(dataset, renderer, types);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getPieChartView(Context context, CategorySeries dataset, DefaultRenderer renderer) {
+        checkParameters(dataset, renderer);
+        PieChart chart = new PieChart(dataset, renderer);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getDialChartView(Context context, CategorySeries dataset, DialRenderer renderer) {
+        checkParameters((CategorySeries) dataset, (DefaultRenderer) renderer);
+        DialChart chart = new DialChart(dataset, renderer);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final GraphicalView getDoughnutChartView(Context context, MultipleCategorySeries dataset, DefaultRenderer renderer) {
+        checkParameters(dataset, renderer);
+        DoughnutChart chart = new DoughnutChart(dataset, renderer);
+        return new GraphicalView(context, chart);
+    }
+
+    public static final Intent getLineChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        return getLineChartIntent(context, dataset, renderer, "");
+    }
+
+    public static final Intent getCubicLineChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, float smoothness) {
+        return getCubicLineChartIntent(context, dataset, renderer, smoothness, "");
+    }
+
+    public static final Intent getScatterChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        return getScatterChartIntent(context, dataset, renderer, "");
+    }
+
+    public static final Intent getBubbleChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        return getBubbleChartIntent(context, dataset, renderer, "");
+    }
+
+    public static final Intent getTimeChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, String format) {
+        return getTimeChartIntent(context, dataset, renderer, format, "");
+    }
+
+    public static final Intent getBarChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, BarChart.Type type) {
+        return getBarChartIntent(context, dataset, renderer, type, "");
+    }
+
+    public static final Intent getLineChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        XYChart chart = new LineChart(dataset, renderer);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getCubicLineChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, float smoothness, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        XYChart chart = new CubicLineChart(dataset, renderer, smoothness);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getScatterChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        XYChart chart = new ScatterChart(dataset, renderer);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getBubbleChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        XYChart chart = new BubbleChart(dataset, renderer);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getTimeChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, String format, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        TimeChart chart = new TimeChart(dataset, renderer);
+        chart.setDateFormat(format);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getBarChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, BarChart.Type type, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        BarChart chart = new BarChart(dataset, renderer, type);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getRangeBarChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, BarChart.Type type, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        RangeBarChart chart = new RangeBarChart(dataset, renderer, type);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getCombinedXYChartIntent(Context context, XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, CombinedXYChart.XYCombinedChartDef[] types, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        CombinedXYChart chart = new CombinedXYChart(dataset, renderer, types);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getPieChartIntent(Context context, CategorySeries dataset, DefaultRenderer renderer, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        PieChart chart = new PieChart(dataset, renderer);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getDoughnutChartIntent(Context context, MultipleCategorySeries dataset, DefaultRenderer renderer, String activityTitle) {
+        checkParameters(dataset, renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        DoughnutChart chart = new DoughnutChart(dataset, renderer);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    public static final Intent getDialChartIntent(Context context, CategorySeries dataset, DialRenderer renderer, String activityTitle) {
+        checkParameters((CategorySeries) dataset, (DefaultRenderer) renderer);
+        Intent intent = new Intent(context, GraphicalActivity.class);
+        DialChart chart = new DialChart(dataset, renderer);
+        intent.putExtra("chart", chart);
+        intent.putExtra("title", activityTitle);
+        return intent;
+    }
+
+    private static void checkParameters(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        if (dataset == null || renderer == null || dataset.getSeriesCount() != renderer.getSeriesRendererCount()) {
+            throw new IllegalArgumentException("Dataset and renderer should be not null and should have the same number of series");
+        }
+    }
+
+    private static void checkParameters(CategorySeries dataset, DefaultRenderer renderer) {
+        if (dataset == null || renderer == null || dataset.getItemCount() != renderer.getSeriesRendererCount()) {
+            throw new IllegalArgumentException("Dataset and renderer should be not null and the dataset number of items should be equal to the number of series renderers");
+        }
+    }
+
+    private static void checkParameters(MultipleCategorySeries dataset, DefaultRenderer renderer) {
+        if (dataset == null || renderer == null || !checkMultipleSeriesItems(dataset, renderer.getSeriesRendererCount())) {
+            throw new IllegalArgumentException("Titles and values should be not null and the dataset number of items should be equal to the number of series renderers");
+        }
+    }
+
+    private static boolean checkMultipleSeriesItems(MultipleCategorySeries dataset, int value) {
+        int count = dataset.getCategoriesCount();
+        boolean equal = true;
+
+        for (int k = 0; k < count && equal; ++k) {
+            equal = dataset.getValues(k).length == dataset.getTitles(k).length;
+        }
+
+        return equal;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/GraphicalView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/GraphicalView.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/GraphicalView.java	(date 1580376425000)
@@ -0,0 +1,249 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.os.Build.VERSION;
+import android.os.Handler;
+import android.view.MotionEvent;
+import android.view.View;
+
+import www.jingkan.com.view.chart.achartengine.chart.AbstractChart;
+import www.jingkan.com.view.chart.achartengine.chart.RoundChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+import www.jingkan.com.view.chart.achartengine.model.Point;
+import www.jingkan.com.view.chart.achartengine.model.SeriesSelection;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.tools.FitZoom;
+import www.jingkan.com.view.chart.achartengine.tools.PanListener;
+import www.jingkan.com.view.chart.achartengine.tools.Zoom;
+import www.jingkan.com.view.chart.achartengine.tools.ZoomListener;
+
+
+public class GraphicalView extends View {
+    private AbstractChart mChart;
+    private DefaultRenderer mRenderer;
+    private Rect mRect = new Rect();
+    private Handler mHandler;
+    private RectF mZoomR = new RectF();
+    private Bitmap zoomInImage;
+    private Bitmap zoomOutImage;
+    private Bitmap fitZoomImage;
+    private int zoomSize = 50;
+    private static final int ZOOM_BUTTONS_COLOR = Color.argb(175, 150, 150, 150);
+    private Zoom mZoomIn;
+    private Zoom mZoomOut;
+    private FitZoom mFitZoom;
+    private Paint mPaint = new Paint();
+    private ITouchHandler mTouchHandler;
+    private float oldX;
+    private float oldY;
+    private boolean mDrawn;
+
+    public GraphicalView(Context context, AbstractChart chart) {
+        super(context);
+        this.mChart = chart;
+        this.mHandler = new Handler();
+        if (this.mChart instanceof XYChart) {
+            this.mRenderer = ((XYChart) this.mChart).getRenderer();
+        } else {
+            this.mRenderer = ((RoundChart) this.mChart).getRenderer();
+        }
+
+        if (this.mRenderer.isZoomButtonsVisible()) {
+            this.zoomInImage = BitmapFactory.decodeStream(GraphicalView.class.getResourceAsStream("image/zoom_in.png"));
+            this.zoomOutImage = BitmapFactory.decodeStream(GraphicalView.class.getResourceAsStream("image/zoom_out.png"));
+            this.fitZoomImage = BitmapFactory.decodeStream(GraphicalView.class.getResourceAsStream("image/zoom-1.png"));
+        }
+
+        if (this.mRenderer instanceof XYMultipleSeriesRenderer && ((XYMultipleSeriesRenderer) this.mRenderer).getMarginsColor() == 0) {
+            ((XYMultipleSeriesRenderer) this.mRenderer).setMarginsColor(this.mPaint.getColor());
+        }
+
+        if (this.mRenderer.isZoomEnabled() && this.mRenderer.isZoomButtonsVisible() || this.mRenderer.isExternalZoomEnabled()) {
+            this.mZoomIn = new Zoom(this.mChart, true, this.mRenderer.getZoomRate());
+            this.mZoomOut = new Zoom(this.mChart, false, this.mRenderer.getZoomRate());
+            this.mFitZoom = new FitZoom(this.mChart);
+        }
+
+        int version = 7;
+
+        try {
+            version = Integer.valueOf(VERSION.SDK);
+        } catch (Exception var5) {
+        }
+
+        if (version < 7) {
+            this.mTouchHandler = new TouchHandlerOld(this, this.mChart);
+        } else {
+            this.mTouchHandler = new TouchHandler(this, this.mChart);
+        }
+
+    }
+
+    public SeriesSelection getCurrentSeriesAndPoint() {
+        return this.mChart.getSeriesAndPointForScreenCoordinate(new Point(this.oldX, this.oldY));
+    }
+
+    public boolean isChartDrawn() {
+        return this.mDrawn;
+    }
+
+    public double[] toRealPoint(int scale) {
+        if (this.mChart instanceof XYChart) {
+            XYChart chart = (XYChart) this.mChart;
+            return chart.toRealPoint(this.oldX, this.oldY, scale);
+        } else {
+            return null;
+        }
+    }
+
+    public AbstractChart getChart() {
+        return this.mChart;
+    }
+
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+        canvas.getClipBounds(this.mRect);
+        int top = this.mRect.top;
+        int left = this.mRect.left;
+        int width = this.mRect.width();
+        int height = this.mRect.height();
+        if (this.mRenderer.isInScroll()) {
+            top = 0;
+            left = 0;
+            width = this.getMeasuredWidth();
+            height = this.getMeasuredHeight();
+        }
+
+        this.mChart.draw(canvas, left, top, width, height, this.mPaint);
+        if (this.mRenderer != null && this.mRenderer.isZoomEnabled() && this.mRenderer.isZoomButtonsVisible()) {
+            this.mPaint.setColor(ZOOM_BUTTONS_COLOR);
+            this.zoomSize = Math.max(this.zoomSize, Math.min(width, height) / 7);
+            this.mZoomR.set((float) (left + width - this.zoomSize * 3), (float) (top + height) - (float) this.zoomSize * 0.775F, (float) (left + width), (float) (top + height));
+            canvas.drawRoundRect(this.mZoomR, (float) (this.zoomSize / 3), (float) (this.zoomSize / 3), this.mPaint);
+            float buttonY = (float) (top + height) - (float) this.zoomSize * 0.625F;
+            canvas.drawBitmap(this.zoomInImage, (float) (left + width) - (float) this.zoomSize * 2.75F, buttonY, (Paint) null);
+            canvas.drawBitmap(this.zoomOutImage, (float) (left + width) - (float) this.zoomSize * 1.75F, buttonY, (Paint) null);
+            canvas.drawBitmap(this.fitZoomImage, (float) (left + width) - (float) this.zoomSize * 0.75F, buttonY, (Paint) null);
+        }
+
+        this.mDrawn = true;
+    }
+
+    public void setZoomRate(float rate) {
+        if (this.mZoomIn != null && this.mZoomOut != null) {
+            this.mZoomIn.setZoomRate(rate);
+            this.mZoomOut.setZoomRate(rate);
+        }
+
+    }
+
+    public void zoomIn() {
+        if (this.mZoomIn != null) {
+            this.mZoomIn.apply(0);
+            this.repaint();
+        }
+
+    }
+
+    public void zoomOut() {
+        if (this.mZoomOut != null) {
+            this.mZoomOut.apply(0);
+            this.repaint();
+        }
+
+    }
+
+    public void zoomReset() {
+        if (this.mFitZoom != null) {
+            this.mFitZoom.apply();
+            this.mZoomIn.notifyZoomResetListeners();
+            this.repaint();
+        }
+
+    }
+
+    public void addZoomListener(ZoomListener listener, boolean onButtons, boolean onPinch) {
+        if (onButtons && this.mZoomIn != null) {
+            this.mZoomIn.addZoomListener(listener);
+            this.mZoomOut.addZoomListener(listener);
+        }
+
+        if (onPinch) {
+            this.mTouchHandler.addZoomListener(listener);
+        }
+
+    }
+
+    public synchronized void removeZoomListener(ZoomListener listener) {
+        if (this.mZoomIn != null) {
+            this.mZoomIn.removeZoomListener(listener);
+            this.mZoomOut.removeZoomListener(listener);
+        }
+
+        this.mTouchHandler.removeZoomListener(listener);
+    }
+
+    public void addPanListener(PanListener listener) {
+        this.mTouchHandler.addPanListener(listener);
+    }
+
+    public void removePanListener(PanListener listener) {
+        this.mTouchHandler.removePanListener(listener);
+    }
+
+    protected RectF getZoomRectangle() {
+        return this.mZoomR;
+    }
+
+    public boolean onTouchEvent(MotionEvent event) {
+        if (event.getAction() == 0) {
+            this.oldX = event.getX();
+            this.oldY = event.getY();
+        }
+
+        return this.mRenderer != null && this.mDrawn && (this.mRenderer.isPanEnabled() || this.mRenderer.isZoomEnabled()) && this.mTouchHandler.handleTouch(event) ? true : super.onTouchEvent(event);
+    }
+
+    public void repaint() {
+        this.mHandler.post(new Runnable() {
+            public void run() {
+                GraphicalView.this.invalidate();
+            }
+        });
+    }
+
+    public void repaint(final int left, final int top, final int right, final int bottom) {
+        this.mHandler.post(new Runnable() {
+            public void run() {
+                GraphicalView.this.invalidate(left, top, right, bottom);
+            }
+        });
+    }
+
+    public Bitmap toBitmap() {
+        this.setDrawingCacheEnabled(false);
+        if (!this.isDrawingCacheEnabled()) {
+            this.setDrawingCacheEnabled(true);
+        }
+
+        if (this.mRenderer.isApplyBackgroundColor()) {
+            this.setDrawingCacheBackgroundColor(this.mRenderer.getBackgroundColor());
+        }
+
+        this.setDrawingCacheQuality(DRAWING_CACHE_QUALITY_AUTO);
+        return this.getDrawingCache(true);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/GraphicalActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/GraphicalActivity.java	(date 1580280491000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/GraphicalActivity.java	(date 1580280491000)
@@ -0,0 +1,37 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine;
+
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.os.Bundle;
+
+import org.achartengine.GraphicalView;
+import org.achartengine.chart.AbstractChart;
+
+@SuppressLint("Registered")
+public class GraphicalActivity extends Activity {
+    private GraphicalView mView;
+    private AbstractChart mChart;
+
+    public GraphicalActivity() {
+    }
+
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Bundle extras = this.getIntent().getExtras();
+        this.mChart = (AbstractChart) extras.getSerializable("chart");
+        this.mView = new GraphicalView(this, this.mChart);
+        String title = extras.getString("title");
+        if (title == null) {
+            this.requestWindowFeature(1);
+        } else if (title.length() > 0) {
+            this.setTitle(title);
+        }
+
+        this.setContentView(this.mView);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/TouchHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/TouchHandler.java	(date 1580376426000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/TouchHandler.java	(date 1580376426000)
@@ -0,0 +1,161 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine;
+
+import android.graphics.RectF;
+import android.view.MotionEvent;
+
+import www.jingkan.com.view.chart.achartengine.chart.AbstractChart;
+import www.jingkan.com.view.chart.achartengine.chart.RoundChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.tools.Pan;
+import www.jingkan.com.view.chart.achartengine.tools.PanListener;
+import www.jingkan.com.view.chart.achartengine.tools.Zoom;
+import www.jingkan.com.view.chart.achartengine.tools.ZoomListener;
+
+
+public class TouchHandler implements ITouchHandler {
+    private DefaultRenderer mRenderer;
+    private float oldX;
+    private float oldY;
+    private float oldX2;
+    private float oldY2;
+    private RectF zoomR;
+    private Pan mPan;
+    private Zoom mPinchZoom;
+    private GraphicalView graphicalView;
+
+    public TouchHandler(GraphicalView view, AbstractChart chart) {
+        this.graphicalView = view;
+        this.zoomR = this.graphicalView.getZoomRectangle();
+        if (chart instanceof XYChart) {
+            this.mRenderer = ((XYChart) chart).getRenderer();
+        } else {
+            this.mRenderer = ((RoundChart) chart).getRenderer();
+        }
+
+        if (this.mRenderer.isPanEnabled()) {
+            this.mPan = new Pan(chart);
+        }
+
+        if (this.mRenderer.isZoomEnabled()) {
+            this.mPinchZoom = new Zoom(chart, true, 1.0F);
+        }
+
+    }
+
+    public boolean handleTouch(MotionEvent event) {
+        int action = event.getAction();
+        if (this.mRenderer != null && action == 2) {
+            if (this.oldX >= 0.0F || this.oldY >= 0.0F) {
+                float newX = event.getX(0);
+                float newY = event.getY(0);
+                if (event.getPointerCount() > 1 && (this.oldX2 >= 0.0F || this.oldY2 >= 0.0F) && this.mRenderer.isZoomEnabled()) {
+                    float newX2 = event.getX(1);
+                    float newY2 = event.getY(1);
+                    float newDeltaX = Math.abs(newX - newX2);
+                    float newDeltaY = Math.abs(newY - newY2);
+                    float oldDeltaX = Math.abs(this.oldX - this.oldX2);
+                    float oldDeltaY = Math.abs(this.oldY - this.oldY2);
+                    float zoomRate;
+                    float tan1 = Math.abs(newY - this.oldY) / Math.abs(newX - this.oldX);
+                    float tan2 = Math.abs(newY2 - this.oldY2) / Math.abs(newX2 - this.oldX2);
+                    if ((double) tan1 <= 0.25D && (double) tan2 <= 0.25D) {
+                        zoomRate = newDeltaX / oldDeltaX;
+                        this.applyZoom(zoomRate, 1);
+                    } else if ((double) tan1 >= 3.73D && (double) tan2 >= 3.73D) {
+                        zoomRate = newDeltaY / oldDeltaY;
+                        this.applyZoom(zoomRate, 2);
+                    } else {
+                        if (Math.abs(newX - this.oldX) >= Math.abs(newY - this.oldY)) {
+                            zoomRate = newDeltaX / oldDeltaX;
+                        } else {
+                            zoomRate = newDeltaY / oldDeltaY;
+                        }
+
+                        this.applyZoom(zoomRate, 0);
+                    }
+
+                    this.oldX2 = newX2;
+                    this.oldY2 = newY2;
+                } else if (this.mRenderer.isPanEnabled()) {
+                    this.mPan.apply(this.oldX, this.oldY, newX, newY);
+                    this.oldX2 = 0.0F;
+                    this.oldY2 = 0.0F;
+                }
+
+                this.oldX = newX;
+                this.oldY = newY;
+                this.graphicalView.repaint();
+                return true;
+            }
+        } else if (action == 0) {
+            this.oldX = event.getX(0);
+            this.oldY = event.getY(0);
+            if (this.mRenderer != null && this.mRenderer.isZoomEnabled() && this.zoomR.contains(this.oldX, this.oldY)) {
+                if (this.oldX < this.zoomR.left + this.zoomR.width() / 3.0F) {
+                    this.graphicalView.zoomIn();
+                } else if (this.oldX < this.zoomR.left + this.zoomR.width() * 2.0F / 3.0F) {
+                    this.graphicalView.zoomOut();
+                } else {
+                    this.graphicalView.zoomReset();
+                }
+
+                return true;
+            }
+        } else if (action == 1 || action == 6) {
+            this.oldX = 0.0F;
+            this.oldY = 0.0F;
+            this.oldX2 = 0.0F;
+            this.oldY2 = 0.0F;
+            if (action == 6) {
+                this.oldX = -1.0F;
+                this.oldY = -1.0F;
+            }
+        }
+
+        return !this.mRenderer.isClickEnabled();
+    }
+
+    private void applyZoom(float zoomRate, int axis) {
+        zoomRate = Math.max(zoomRate, 0.9F);
+        zoomRate = Math.min(zoomRate, 1.1F);
+        if (this.mPinchZoom != null && (double) zoomRate > 0.9D && (double) zoomRate < 1.1D) {
+            this.mPinchZoom.setZoomRate(zoomRate);
+            this.mPinchZoom.apply(axis);
+        }
+
+    }
+
+    public void addZoomListener(ZoomListener listener) {
+        if (this.mPinchZoom != null) {
+            this.mPinchZoom.addZoomListener(listener);
+        }
+
+    }
+
+    public void removeZoomListener(ZoomListener listener) {
+        if (this.mPinchZoom != null) {
+            this.mPinchZoom.removeZoomListener(listener);
+        }
+
+    }
+
+    public void addPanListener(PanListener listener) {
+        if (this.mPan != null) {
+            this.mPan.addPanListener(listener);
+        }
+
+    }
+
+    public void removePanListener(PanListener listener) {
+        if (this.mPan != null) {
+            this.mPan.removePanListener(listener);
+        }
+
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/ITouchHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/ITouchHandler.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/ITouchHandler.java	(date 1580374307000)
@@ -0,0 +1,23 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine;
+
+import android.view.MotionEvent;
+
+import www.jingkan.com.view.chart.achartengine.tools.PanListener;
+import www.jingkan.com.view.chart.achartengine.tools.ZoomListener;
+
+public interface ITouchHandler {
+    boolean handleTouch(MotionEvent var1);
+
+    void addZoomListener(ZoomListener var1);
+
+    void removeZoomListener(ZoomListener var1);
+
+    void addPanListener(PanListener var1);
+
+    void removePanListener(PanListener var1);
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/util/IndexXYMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/util/IndexXYMap.java	(date 1580288272000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/util/IndexXYMap.java	(date 1580288272000)
@@ -0,0 +1,76 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.util;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.TreeMap;
+
+public class IndexXYMap<K, V> extends TreeMap<K, V> {
+    private final List<K> indexList = new ArrayList();
+    private double maxXDifference = 0.0D;
+
+    public IndexXYMap() {
+    }
+
+    public V put(K key, V value) {
+        this.indexList.add(key);
+        this.updateMaxXDifference();
+        return super.put(key, value);
+    }
+
+    public V put(int index, K key, V value) {
+        this.indexList.add(index, key);
+        this.updateMaxXDifference();
+        return super.put(key, value);
+    }
+
+    private void updateMaxXDifference() {
+        if (this.indexList.size() < 2) {
+            this.maxXDifference = 0.0D;
+        } else {
+            if (Math.abs((Double) this.indexList.get(this.indexList.size() - 1) - (Double) this.indexList.get(this.indexList.size() - 2)) > this.maxXDifference) {
+                this.maxXDifference = Math.abs((Double) this.indexList.get(this.indexList.size() - 1) - (Double) this.indexList.get(this.indexList.size() - 2));
+            }
+
+        }
+    }
+
+    public double getMaxXDifference() {
+        return this.maxXDifference;
+    }
+
+    public void clear() {
+        this.updateMaxXDifference();
+        super.clear();
+        this.indexList.clear();
+    }
+
+    public K getXByIndex(int index) {
+        return this.indexList.get(index);
+    }
+
+    public V getYByIndex(int index) {
+        K key = this.indexList.get(index);
+        return this.get(key);
+    }
+
+    public XYEntry<K, V> getByIndex(int index) {
+        K key = this.indexList.get(index);
+        return new XYEntry(key, this.get(key));
+    }
+
+    public XYEntry<K, V> removeByIndex(int index) {
+        K key = this.indexList.remove(index);
+        return new XYEntry(key, this.remove(key));
+    }
+
+    public int getIndexForKey(K key) {
+        return Collections.binarySearch(this.indexList, key, (Comparator) null);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/TouchHandlerOld.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/TouchHandlerOld.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/TouchHandlerOld.java	(date 1580374307000)
@@ -0,0 +1,99 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine;
+
+import android.graphics.RectF;
+import android.view.MotionEvent;
+
+import www.jingkan.com.view.chart.achartengine.chart.AbstractChart;
+import www.jingkan.com.view.chart.achartengine.chart.RoundChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.tools.Pan;
+import www.jingkan.com.view.chart.achartengine.tools.PanListener;
+import www.jingkan.com.view.chart.achartengine.tools.ZoomListener;
+
+
+public class TouchHandlerOld implements ITouchHandler {
+    private DefaultRenderer mRenderer;
+    private float oldX;
+    private float oldY;
+    private RectF zoomR = new RectF();
+    private Pan mPan;
+    private GraphicalView graphicalView;
+
+    public TouchHandlerOld(GraphicalView view, AbstractChart chart) {
+        this.graphicalView = view;
+        this.zoomR = this.graphicalView.getZoomRectangle();
+        if (chart instanceof XYChart) {
+            this.mRenderer = ((XYChart) chart).getRenderer();
+        } else {
+            this.mRenderer = ((RoundChart) chart).getRenderer();
+        }
+
+        if (this.mRenderer.isPanEnabled()) {
+            this.mPan = new Pan(chart);
+        }
+
+    }
+
+    public boolean handleTouch(MotionEvent event) {
+        int action = event.getAction();
+        if (this.mRenderer != null && action == 2) {
+            if (this.oldX >= 0.0F || this.oldY >= 0.0F) {
+                float newX = event.getX();
+                float newY = event.getY();
+                if (this.mRenderer.isPanEnabled()) {
+                    this.mPan.apply(this.oldX, this.oldY, newX, newY);
+                }
+
+                this.oldX = newX;
+                this.oldY = newY;
+                this.graphicalView.repaint();
+                return true;
+            }
+        } else if (action == 0) {
+            this.oldX = event.getX();
+            this.oldY = event.getY();
+            if (this.mRenderer != null && this.mRenderer.isZoomEnabled() && this.zoomR.contains(this.oldX, this.oldY)) {
+                if (this.oldX < this.zoomR.left + this.zoomR.width() / 3.0F) {
+                    this.graphicalView.zoomIn();
+                } else if (this.oldX < this.zoomR.left + this.zoomR.width() * 2.0F / 3.0F) {
+                    this.graphicalView.zoomOut();
+                } else {
+                    this.graphicalView.zoomReset();
+                }
+
+                return true;
+            }
+        } else if (action == 1) {
+            this.oldX = 0.0F;
+            this.oldY = 0.0F;
+        }
+
+        return !this.mRenderer.isClickEnabled();
+    }
+
+    public void addZoomListener(ZoomListener listener) {
+    }
+
+    public void removeZoomListener(ZoomListener listener) {
+    }
+
+    public void addPanListener(PanListener listener) {
+        if (this.mPan != null) {
+            this.mPan.addPanListener(listener);
+        }
+
+    }
+
+    public void removePanListener(PanListener listener) {
+        if (this.mPan != null) {
+            this.mPan.removePanListener(listener);
+        }
+
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/util/XYEntry.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/util/XYEntry.java	(date 1580288272000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/util/XYEntry.java	(date 1580288272000)
@@ -0,0 +1,31 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.util;
+
+import java.util.Map.Entry;
+
+public class XYEntry<K, V> implements Entry<K, V> {
+    private final K key;
+    private V value;
+
+    public XYEntry(K key, V value) {
+        this.key = key;
+        this.value = value;
+    }
+
+    public K getKey() {
+        return this.key;
+    }
+
+    public V getValue() {
+        return this.value;
+    }
+
+    public V setValue(V object) {
+        this.value = object;
+        return this.value;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/CrossStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/CrossStrategy.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/chart/CrossStrategy.java	(date 1580376426000)
@@ -7,11 +7,12 @@
 import android.content.Context;
 import android.widget.RelativeLayout;
 
-import org.achartengine.model.XYSeries;
-import org.achartengine.renderer.XYMultipleSeriesRenderer;
 
 import java.util.List;
 
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+
 /**
  * Created by lushengbo on 2018/1/9.
  * 十字板绘图
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/util/MathHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/util/MathHelper.java	(date 1580377350000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/util/MathHelper.java	(date 1580377350000)
@@ -0,0 +1,96 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.util;
+
+import java.text.NumberFormat;
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class MathHelper {
+    public static final double NULL_VALUE = 1.7976931348623157E308D;
+    private static final NumberFormat FORMAT = NumberFormat.getNumberInstance();
+
+    private MathHelper() {
+    }
+
+    public static double[] minmax(List<Double> values) {
+        if (values.size() == 0) {
+            return new double[2];
+        } else {
+            double min = (Double) values.get(0);
+            double max = min;
+            int length = values.size();
+
+            for (int i = 1; i < length; ++i) {
+                double value = (Double) values.get(i);
+                min = Math.min(min, value);
+                max = Math.max(max, value);
+            }
+
+            return new double[]{min, max};
+        }
+    }
+
+    public static List<Double> getLabels(double start, double end, int approxNumLabels) {
+        List<Double> labels = new ArrayList();
+        if (approxNumLabels <= 0) {
+            return labels;
+        } else {
+            FORMAT.setMaximumFractionDigits(5);
+            double[] labelParams = computeLabels(start, end, approxNumLabels);
+            int numLabels = 1 + (int) ((labelParams[1] - labelParams[0]) / labelParams[2]);
+
+            for (int i = 0; i < numLabels; ++i) {
+                double z = labelParams[0] + (double) i * labelParams[2];
+
+                try {
+                    z = FORMAT.parse(FORMAT.format(z)).doubleValue();
+                } catch (ParseException var12) {
+                }
+
+                labels.add(z);
+            }
+
+            return labels;
+        }
+    }
+
+    private static double[] computeLabels(double start, double end, int approxNumLabels) {
+        if (Math.abs(start - end) < 1.0000000116860974E-7D) {
+            return new double[]{start, start, 0.0D};
+        } else {
+            double s = start;
+            double e = end;
+            boolean switched = false;
+            if (start > end) {
+                switched = true;
+                s = end;
+                e = start;
+            }
+
+            double xStep = roundUp(Math.abs(s - e) / (double) approxNumLabels);
+            double xStart = xStep * Math.ceil(s / xStep);
+            double xEnd = xStep * Math.floor(e / xStep);
+            return switched ? new double[]{xEnd, xStart, -1.0D * xStep} : new double[]{xStart, xEnd, xStep};
+        }
+    }
+
+    private static double roundUp(double val) {
+        int exponent = (int) Math.floor(Math.log10(val));
+        double rval = val * Math.pow(10.0D, (double) (-exponent));
+        if (rval > 5.0D) {
+            rval = 10.0D;
+        } else if (rval > 2.0D) {
+            rval = 5.0D;
+        } else if (rval > 1.0D) {
+            rval = 2.0D;
+        }
+
+        rval *= Math.pow(10.0D, (double) exponent);
+        return rval;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/SingleBridgeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/SingleBridgeStrategy.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/chart/SingleBridgeStrategy.java	(date 1580376426000)
@@ -10,17 +10,17 @@
 import android.view.ViewGroup;
 import android.widget.RelativeLayout;
 
-import org.achartengine.ChartFactory;
-import org.achartengine.GraphicalView;
-import org.achartengine.chart.PointStyle;
-import org.achartengine.model.XYMultipleSeriesDataset;
-import org.achartengine.model.XYSeries;
-import org.achartengine.renderer.XYMultipleSeriesRenderer;
-import org.achartengine.renderer.XYSeriesRenderer;
-import org.achartengine.util.IndexXYMap;
-
 import java.util.List;
 
+import www.jingkan.com.view.chart.achartengine.ChartFactory;
+import www.jingkan.com.view.chart.achartengine.GraphicalView;
+import www.jingkan.com.view.chart.achartengine.chart.PointStyle;
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.util.IndexXYMap;
+
 /**
  * Created by lushengbo on 2018/1/4.
  * 单桥绘图
@@ -132,7 +132,7 @@
         mRenderer.setYAxisMax(15);
         mRenderer.setXAxisMax(10);
         setOrientation();
-        mRenderer.setChartTitleTextSize(20);
+        mRenderer.setChartTitleTextSize(40);
         mRenderer.setMargins(new int[]{50, 50, 100, 50});//右，上，左，下
         mRenderer.setYLabelsPadding(-10);
         setXYTitle();
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYSeries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYSeries.java	(date 1580377350000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYSeries.java	(date 1580377350000)
@@ -0,0 +1,215 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.model;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.SortedMap;
+import java.util.TreeMap;
+
+import www.jingkan.com.view.chart.achartengine.util.IndexXYMap;
+import www.jingkan.com.view.chart.achartengine.util.XYEntry;
+
+public class XYSeries implements Serializable {
+    private String mTitle;
+    private final IndexXYMap<Double, Double> mXY;
+    private double mMinX;
+    private double mMaxX;
+    private double mMinY;
+    private double mMaxY;
+    private final int mScaleNumber;
+    private List<String> mAnnotations;
+    private final IndexXYMap<Double, Double> mStringXY;
+
+    public XYSeries(String title) {
+        this(title, 0);
+    }
+
+    public XYSeries(String title, int scaleNumber) {
+        this.mXY = new IndexXYMap();
+        this.mMinX = 1.7976931348623157E308D;
+        this.mMaxX = -1.7976931348623157E308D;
+        this.mMinY = 1.7976931348623157E308D;
+        this.mMaxY = -1.7976931348623157E308D;
+        this.mAnnotations = new ArrayList();
+        this.mStringXY = new IndexXYMap();
+        this.mTitle = title;
+        this.mScaleNumber = scaleNumber;
+        this.initRange();
+    }
+
+    public int getScaleNumber() {
+        return this.mScaleNumber;
+    }
+
+    private void initRange() {
+        this.mMinX = 1.7976931348623157E308D;
+        this.mMaxX = -1.7976931348623157E308D;
+        this.mMinY = 1.7976931348623157E308D;
+        this.mMaxY = -1.7976931348623157E308D;
+        int length = this.getItemCount();
+
+        for (int k = 0; k < length; ++k) {
+            double x = this.getX(k);
+            double y = this.getY(k);
+            this.updateRange(x, y);
+        }
+
+    }
+
+    private void updateRange(double x, double y) {
+        this.mMinX = Math.min(this.mMinX, x);
+        this.mMaxX = Math.max(this.mMaxX, x);
+        this.mMinY = Math.min(this.mMinY, y);
+        this.mMaxY = Math.max(this.mMaxY, y);
+    }
+
+    public String getTitle() {
+        return this.mTitle;
+    }
+
+    public void setTitle(String title) {
+        this.mTitle = title;
+    }
+
+    public synchronized void add(double x, double y) {
+        while (this.mXY.get(x) != null) {
+            x += this.getPadding(x);
+        }
+
+        this.mXY.put(x, y);
+        this.updateRange(x, y);
+    }
+
+    public synchronized void add(int index, double x, double y) {
+        while (this.mXY.get(x) != null) {
+            x += this.getPadding(x);
+        }
+
+        this.mXY.put(index, x, y);
+        this.updateRange(x, y);
+    }
+
+    protected double getPadding(double x) {
+        return Math.ulp(x);
+    }
+
+    public synchronized void remove(int index) {
+        XYEntry<Double, Double> removedEntry = this.mXY.removeByIndex(index);
+        double removedX = removedEntry.getKey();
+        double removedY = removedEntry.getValue();
+        if (removedX == this.mMinX || removedX == this.mMaxX || removedY == this.mMinY || removedY == this.mMaxY) {
+            this.initRange();
+        }
+
+    }
+
+    public synchronized void clear() {
+        this.clearAnnotations();
+        this.clearSeriesValues();
+    }
+
+    public synchronized void clearSeriesValues() {
+        this.mXY.clear();
+        this.initRange();
+    }
+
+    public synchronized void clearAnnotations() {
+        this.mAnnotations.clear();
+        this.mStringXY.clear();
+    }
+
+    public synchronized IndexXYMap<Double, Double> getXYMap() {
+        return this.mXY;
+    }
+
+    public synchronized double getX(int index) {
+        return (Double) this.mXY.getXByIndex(index);
+    }
+
+    public synchronized double getY(int index) {
+        return (Double) this.mXY.getYByIndex(index);
+    }
+
+    public void addAnnotation(String annotation, double x, double y) {
+        this.mAnnotations.add(annotation);
+
+        while (this.mStringXY.get(x) != null) {
+            x += this.getPadding(x);
+        }
+
+        this.mStringXY.put(x, y);
+    }
+
+    public void removeAnnotation(int index) {
+        this.mAnnotations.remove(index);
+        this.mStringXY.removeByIndex(index);
+    }
+
+    public double getAnnotationX(int index) {
+        return (Double) this.mStringXY.getXByIndex(index);
+    }
+
+    public double getAnnotationY(int index) {
+        return (Double) this.mStringXY.getYByIndex(index);
+    }
+
+    public int getAnnotationCount() {
+        return this.mAnnotations.size();
+    }
+
+    public String getAnnotationAt(int index) {
+        return (String) this.mAnnotations.get(index);
+    }
+
+    public synchronized SortedMap<Double, Double> getRange(double start, double stop, boolean beforeAfterPoints) {
+        if (beforeAfterPoints) {
+            SortedMap<Double, Double> headMap = this.mXY.headMap(start);
+            if (!headMap.isEmpty()) {
+                start = (Double) headMap.lastKey();
+            }
+
+            SortedMap<Double, Double> tailMap = this.mXY.tailMap(stop);
+            if (!tailMap.isEmpty()) {
+                Iterator<Double> tailIterator = tailMap.keySet().iterator();
+                Double next = (Double) tailIterator.next();
+                if (tailIterator.hasNext()) {
+                    stop = (Double) tailIterator.next();
+                } else {
+                    stop += next;
+                }
+            }
+        }
+
+        return (SortedMap) (start <= stop ? this.mXY.subMap(start, stop) : new TreeMap());
+    }
+
+    public int getIndexForKey(double key) {
+        return this.mXY.getIndexForKey(key);
+    }
+
+    public synchronized int getItemCount() {
+        return this.mXY.size();
+    }
+
+    public double getMinX() {
+        return this.mMinX;
+    }
+
+    public double getMinY() {
+        return this.mMinY;
+    }
+
+    public double getMaxX() {
+        return this.mMaxX;
+    }
+
+    public double getMaxY() {
+        return this.mMaxY;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYMultipleSeriesDataset.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYMultipleSeriesDataset.java	(date 1580377350000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYMultipleSeriesDataset.java	(date 1580377350000)
@@ -0,0 +1,53 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.model;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+public class XYMultipleSeriesDataset implements Serializable {
+    private List<XYSeries> mSeries = new ArrayList();
+
+    public XYMultipleSeriesDataset() {
+    }
+
+    public synchronized void addSeries(XYSeries series) {
+        this.mSeries.add(series);
+    }
+
+    public synchronized void addSeries(int index, XYSeries series) {
+        this.mSeries.add(index, series);
+    }
+
+    public synchronized void addAllSeries(List<XYSeries> series) {
+        this.mSeries.addAll(series);
+    }
+
+    public synchronized void removeSeries(int index) {
+        this.mSeries.remove(index);
+    }
+
+    public synchronized void removeSeries(XYSeries series) {
+        this.mSeries.remove(series);
+    }
+
+    public synchronized void clear() {
+        this.mSeries.clear();
+    }
+
+    public synchronized XYSeries getSeriesAt(int index) {
+        return (XYSeries) this.mSeries.get(index);
+    }
+
+    public synchronized int getSeriesCount() {
+        return this.mSeries.size();
+    }
+
+    public synchronized XYSeries[] getSeries() {
+        return (XYSeries[]) this.mSeries.toArray(new XYSeries[0]);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/DefaultRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/DefaultRenderer.java	(date 1580377350000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/DefaultRenderer.java	(date 1580377350000)
@@ -0,0 +1,425 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.renderer;
+
+import android.graphics.Typeface;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+public class DefaultRenderer implements Serializable {
+    private String mChartTitle = "";
+    private float mChartTitleTextSize = 15.0F;
+    public static final int NO_COLOR = 0;
+    public static final int BACKGROUND_COLOR = -16777216;
+    public static final int TEXT_COLOR = -3355444;
+    private static final Typeface REGULAR_TEXT_FONT;
+    private String mTextTypefaceName;
+    private int mTextTypefaceStyle;
+    private Typeface mTextTypeface;
+    private int mBackgroundColor;
+    private boolean mApplyBackgroundColor;
+    private boolean mShowAxes;
+    private int mYAxisColor;
+    private int mXAxisColor;
+    private boolean mShowLabels;
+    private boolean mShowTickMarks;
+    private int mLabelsColor;
+    private float mLabelsTextSize;
+    private boolean mShowLegend;
+    private float mLegendTextSize;
+    private boolean mFitLegend;
+    private boolean mShowGridX;
+    private boolean mShowGridY;
+    private boolean mShowCustomTextGridX;
+    private boolean mShowCustomTextGridY;
+    private List<SimpleSeriesRenderer> mRenderers;
+    private boolean mAntialiasing;
+    private int mLegendHeight;
+    private int[] mMargins;
+    private float mScale;
+    private boolean mPanEnabled;
+    private boolean mZoomEnabled;
+    private boolean mZoomButtonsVisible;
+    private float mZoomRate;
+    private boolean mExternalZoomEnabled;
+    private float mOriginalScale;
+    private boolean mClickEnabled;
+    private int selectableBuffer;
+    private boolean mDisplayValues;
+    private boolean mInScroll;
+    private float mStartAngle;
+
+    public DefaultRenderer() {
+        this.mTextTypefaceName = REGULAR_TEXT_FONT.toString();
+        this.mTextTypefaceStyle = 0;
+        this.mShowAxes = true;
+        this.mYAxisColor = -3355444;
+        this.mXAxisColor = -3355444;
+        this.mShowLabels = true;
+        this.mShowTickMarks = true;
+        this.mLabelsColor = -3355444;
+        this.mLabelsTextSize = 10.0F;
+        this.mShowLegend = true;
+        this.mLegendTextSize = 12.0F;
+        this.mFitLegend = false;
+        this.mShowGridX = false;
+        this.mShowGridY = false;
+        this.mShowCustomTextGridX = false;
+        this.mShowCustomTextGridY = false;
+        this.mRenderers = new ArrayList();
+        this.mAntialiasing = true;
+        this.mLegendHeight = 0;
+        this.mMargins = new int[]{20, 30, 10, 20};
+        this.mScale = 1.0F;
+        this.mPanEnabled = true;
+        this.mZoomEnabled = true;
+        this.mZoomButtonsVisible = false;
+        this.mZoomRate = 1.5F;
+        this.mExternalZoomEnabled = false;
+        this.mOriginalScale = this.mScale;
+        this.mClickEnabled = false;
+        this.selectableBuffer = 15;
+        this.mStartAngle = 0.0F;
+    }
+
+    public String getChartTitle() {
+        return this.mChartTitle;
+    }
+
+    public void setChartTitle(String title) {
+        this.mChartTitle = title;
+    }
+
+    public float getChartTitleTextSize() {
+        return this.mChartTitleTextSize;
+    }
+
+    public void setChartTitleTextSize(float textSize) {
+        this.mChartTitleTextSize = textSize;
+    }
+
+    public void addSeriesRenderer(SimpleSeriesRenderer renderer) {
+        this.mRenderers.add(renderer);
+    }
+
+    public void addSeriesRenderer(int index, SimpleSeriesRenderer renderer) {
+        this.mRenderers.add(index, renderer);
+    }
+
+    public void removeSeriesRenderer(SimpleSeriesRenderer renderer) {
+        this.mRenderers.remove(renderer);
+    }
+
+    public void removeAllRenderers() {
+        this.mRenderers.clear();
+    }
+
+    public SimpleSeriesRenderer getSeriesRendererAt(int index) {
+        return (SimpleSeriesRenderer) this.mRenderers.get(index);
+    }
+
+    public int getSeriesRendererCount() {
+        return this.mRenderers.size();
+    }
+
+    public SimpleSeriesRenderer[] getSeriesRenderers() {
+        return (SimpleSeriesRenderer[]) this.mRenderers.toArray(new SimpleSeriesRenderer[0]);
+    }
+
+    public int getBackgroundColor() {
+        return this.mBackgroundColor;
+    }
+
+    public void setBackgroundColor(int color) {
+        this.mBackgroundColor = color;
+    }
+
+    public boolean isApplyBackgroundColor() {
+        return this.mApplyBackgroundColor;
+    }
+
+    public void setApplyBackgroundColor(boolean apply) {
+        this.mApplyBackgroundColor = apply;
+    }
+
+    public int getAxesColor() {
+        return this.mXAxisColor != -3355444 ? this.mXAxisColor : this.mYAxisColor;
+    }
+
+    public void setAxesColor(int color) {
+        this.setXAxisColor(color);
+        this.setYAxisColor(color);
+    }
+
+    public int getYAxisColor() {
+        return this.mYAxisColor;
+    }
+
+    public void setYAxisColor(int color) {
+        this.mYAxisColor = color;
+    }
+
+    public int getXAxisColor() {
+        return this.mXAxisColor;
+    }
+
+    public void setXAxisColor(int color) {
+        this.mXAxisColor = color;
+    }
+
+    public int getLabelsColor() {
+        return this.mLabelsColor;
+    }
+
+    public void setLabelsColor(int color) {
+        this.mLabelsColor = color;
+    }
+
+    public float getLabelsTextSize() {
+        return this.mLabelsTextSize;
+    }
+
+    public void setLabelsTextSize(float textSize) {
+        this.mLabelsTextSize = textSize;
+    }
+
+    public boolean isShowAxes() {
+        return this.mShowAxes;
+    }
+
+    public void setShowAxes(boolean showAxes) {
+        this.mShowAxes = showAxes;
+    }
+
+    public boolean isShowLabels() {
+        return this.mShowLabels;
+    }
+
+    public void setShowLabels(boolean showLabels) {
+        this.mShowLabels = showLabels;
+    }
+
+    public boolean isShowTickMarks() {
+        return this.mShowTickMarks;
+    }
+
+    public void setShowTickMarks(boolean mShowTickMarks) {
+        this.mShowTickMarks = mShowTickMarks;
+    }
+
+    public boolean isShowGridX() {
+        return this.mShowGridX;
+    }
+
+    public boolean isShowGridY() {
+        return this.mShowGridY;
+    }
+
+    public void setShowGridX(boolean showGrid) {
+        this.mShowGridX = showGrid;
+    }
+
+    public void setShowGridY(boolean showGrid) {
+        this.mShowGridY = showGrid;
+    }
+
+    public void setShowGrid(boolean showGrid) {
+        this.setShowGridX(showGrid);
+        this.setShowGridY(showGrid);
+    }
+
+    public boolean isShowCustomTextGridX() {
+        return this.mShowCustomTextGridX;
+    }
+
+    public boolean isShowCustomTextGridY() {
+        return this.mShowCustomTextGridY;
+    }
+
+    public void setShowCustomTextGridX(boolean showGrid) {
+        this.mShowCustomTextGridX = showGrid;
+    }
+
+    public void setShowCustomTextGridY(boolean showGrid) {
+        this.mShowCustomTextGridY = showGrid;
+    }
+
+    public void setShowCustomTextGrid(boolean showGrid) {
+        this.setShowCustomTextGridX(showGrid);
+        this.setShowCustomTextGridY(showGrid);
+    }
+
+    public boolean isShowLegend() {
+        return this.mShowLegend;
+    }
+
+    public void setShowLegend(boolean showLegend) {
+        this.mShowLegend = showLegend;
+    }
+
+    public boolean isFitLegend() {
+        return this.mFitLegend;
+    }
+
+    public void setFitLegend(boolean fit) {
+        this.mFitLegend = fit;
+    }
+
+    public String getTextTypefaceName() {
+        return this.mTextTypefaceName;
+    }
+
+    public int getTextTypefaceStyle() {
+        return this.mTextTypefaceStyle;
+    }
+
+    public Typeface getTextTypeface() {
+        return this.mTextTypeface;
+    }
+
+    public float getLegendTextSize() {
+        return this.mLegendTextSize;
+    }
+
+    public void setLegendTextSize(float textSize) {
+        this.mLegendTextSize = textSize;
+    }
+
+    public void setTextTypeface(String typefaceName, int style) {
+        this.mTextTypefaceName = typefaceName;
+        this.mTextTypefaceStyle = style;
+    }
+
+    public void setTextTypeface(Typeface typeface) {
+        this.mTextTypeface = typeface;
+    }
+
+    public boolean isAntialiasing() {
+        return this.mAntialiasing;
+    }
+
+    public void setAntialiasing(boolean antialiasing) {
+        this.mAntialiasing = antialiasing;
+    }
+
+    public float getScale() {
+        return this.mScale;
+    }
+
+    public float getOriginalScale() {
+        return this.mOriginalScale;
+    }
+
+    public void setScale(float scale) {
+        this.mScale = scale;
+    }
+
+    public boolean isZoomEnabled() {
+        return this.mZoomEnabled;
+    }
+
+    public void setZoomEnabled(boolean enabled) {
+        this.mZoomEnabled = enabled;
+    }
+
+    public boolean isZoomButtonsVisible() {
+        return this.mZoomButtonsVisible;
+    }
+
+    public void setZoomButtonsVisible(boolean visible) {
+        this.mZoomButtonsVisible = visible;
+    }
+
+    public boolean isExternalZoomEnabled() {
+        return this.mExternalZoomEnabled;
+    }
+
+    public void setExternalZoomEnabled(boolean enabled) {
+        this.mExternalZoomEnabled = enabled;
+    }
+
+    public float getZoomRate() {
+        return this.mZoomRate;
+    }
+
+    public boolean isPanEnabled() {
+        return this.mPanEnabled;
+    }
+
+    public void setPanEnabled(boolean enabled) {
+        this.mPanEnabled = enabled;
+    }
+
+    public void setZoomRate(float rate) {
+        this.mZoomRate = rate;
+    }
+
+    public boolean isClickEnabled() {
+        return this.mClickEnabled;
+    }
+
+    public void setClickEnabled(boolean enabled) {
+        this.mClickEnabled = enabled;
+    }
+
+    public int getSelectableBuffer() {
+        return this.selectableBuffer;
+    }
+
+    public void setSelectableBuffer(int buffer) {
+        this.selectableBuffer = buffer;
+    }
+
+    public int getLegendHeight() {
+        return this.mLegendHeight;
+    }
+
+    public void setLegendHeight(int height) {
+        this.mLegendHeight = height;
+    }
+
+    public int[] getMargins() {
+        return this.mMargins;
+    }
+
+    public void setMargins(int[] margins) {
+        this.mMargins = margins;
+    }
+
+    public boolean isInScroll() {
+        return this.mInScroll;
+    }
+
+    public void setInScroll(boolean inScroll) {
+        this.mInScroll = inScroll;
+    }
+
+    public float getStartAngle() {
+        return this.mStartAngle;
+    }
+
+    public void setStartAngle(float startAngle) {
+        while (startAngle < 0.0F) {
+            startAngle += 360.0F;
+        }
+
+        this.mStartAngle = startAngle;
+    }
+
+    public boolean isDisplayValues() {
+        return this.mDisplayValues;
+    }
+
+    public void setDisplayValues(boolean display) {
+        this.mDisplayValues = display;
+    }
+
+    static {
+        REGULAR_TEXT_FONT = Typeface.create(Typeface.SERIF, 0);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/XYMultipleSeriesRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/XYMultipleSeriesRenderer.java	(date 1580288887000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/XYMultipleSeriesRenderer.java	(date 1580288887000)
@@ -0,0 +1,664 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.renderer;
+
+import android.graphics.Color;
+import android.graphics.Paint.Align;
+
+import java.text.NumberFormat;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public class XYMultipleSeriesRenderer extends DefaultRenderer {
+    private String mXTitle;
+    private String[] mYTitle;
+    private float mAxisTitleTextSize;
+    private double[] mMinX;
+    private double[] mMaxX;
+    private double[] mMinY;
+    private double[] mMaxY;
+    private int mXLabels;
+    private int mYLabels;
+    private XYMultipleSeriesRenderer.Orientation mOrientation;
+    private Map<Double, String> mXTextLabels;
+    private Map<Integer, Map<Double, String>> mYTextLabels;
+    private boolean mPanXEnabled;
+    private boolean mPanYEnabled;
+    private boolean mZoomXEnabled;
+    private boolean mZoomYEnabled;
+    private double mBarSpacing;
+    private int mMarginsColor;
+    private double[] mPanLimits;
+    private double[] mZoomLimits;
+    private float mXLabelsAngle;
+    private float mYLabelsAngle;
+    private Map<Integer, double[]> initialRange;
+    private float mPointSize;
+    private int[] mGridColors;
+    private int scalesCount;
+    private Align xLabelsAlign;
+    private Align[] yLabelsAlign;
+    private float mXLabelsPadding;
+    private float mYLabelsPadding;
+    private float mYLabelsVerticalPadding;
+    private Align[] yAxisAlign;
+    private int mXLabelsColor;
+    private int[] mYLabelsColor;
+    private boolean mXRoundedLabels;
+    private NumberFormat mXLabelFormat;
+    private NumberFormat[] mYLabelFormat;
+    private float mBarWidth;
+    private double mZoomInLimitX;
+    private double mZoomInLimitY;
+
+    public XYMultipleSeriesRenderer() {
+        this(1);
+    }
+
+    public XYMultipleSeriesRenderer(int scaleNumber) {
+        this.mXTitle = "";
+        this.mAxisTitleTextSize = 12.0F;
+        this.mXLabels = 5;
+        this.mYLabels = 5;
+        this.mOrientation = XYMultipleSeriesRenderer.Orientation.HORIZONTAL;
+        this.mXTextLabels = new HashMap();
+        this.mYTextLabels = new LinkedHashMap();
+        this.mPanXEnabled = true;
+        this.mPanYEnabled = true;
+        this.mZoomXEnabled = true;
+        this.mZoomYEnabled = true;
+        this.mBarSpacing = 0.0D;
+        this.mMarginsColor = 0;
+        this.initialRange = new LinkedHashMap();
+        this.mPointSize = 3.0F;
+        this.xLabelsAlign = Align.CENTER;
+        this.mXLabelsPadding = 0.0F;
+        this.mYLabelsPadding = 0.0F;
+        this.mYLabelsVerticalPadding = 2.0F;
+        this.mXLabelsColor = -3355444;
+        this.mYLabelsColor = new int[]{-3355444};
+        this.mXRoundedLabels = true;
+        this.mBarWidth = -1.0F;
+        this.mZoomInLimitX = 0.0D;
+        this.mZoomInLimitY = 0.0D;
+        this.scalesCount = scaleNumber;
+        this.initAxesRange(scaleNumber);
+    }
+
+    public void initAxesRange(int scales) {
+        this.mYTitle = new String[scales];
+        this.yLabelsAlign = new Align[scales];
+        this.yAxisAlign = new Align[scales];
+        this.mYLabelsColor = new int[scales];
+        this.mYLabelFormat = new NumberFormat[scales];
+        this.mMinX = new double[scales];
+        this.mMaxX = new double[scales];
+        this.mMinY = new double[scales];
+        this.mMaxY = new double[scales];
+        this.mGridColors = new int[scales];
+
+        for (int i = 0; i < scales; ++i) {
+            this.mYLabelsColor[i] = -3355444;
+            this.mYLabelFormat[i] = NumberFormat.getNumberInstance();
+            this.mGridColors[i] = Color.argb(75, 200, 200, 200);
+            this.initAxesRangeForScale(i);
+        }
+
+    }
+
+    public void initAxesRangeForScale(int i) {
+        this.mMinX[i] = 1.7976931348623157E308D;
+        this.mMaxX[i] = -1.7976931348623157E308D;
+        this.mMinY[i] = 1.7976931348623157E308D;
+        this.mMaxY[i] = -1.7976931348623157E308D;
+        double[] range = new double[]{this.mMinX[i], this.mMaxX[i], this.mMinY[i], this.mMaxY[i]};
+        this.initialRange.put(i, range);
+        this.mYTitle[i] = "";
+        this.mYTextLabels.put(i, new HashMap());
+        this.yLabelsAlign[i] = Align.CENTER;
+        this.yAxisAlign[i] = Align.LEFT;
+    }
+
+    public XYMultipleSeriesRenderer.Orientation getOrientation() {
+        return this.mOrientation;
+    }
+
+    public void setOrientation(XYMultipleSeriesRenderer.Orientation orientation) {
+        this.mOrientation = orientation;
+    }
+
+    public String getXTitle() {
+        return this.mXTitle;
+    }
+
+    public void setXTitle(String title) {
+        this.mXTitle = title;
+    }
+
+    public String getYTitle() {
+        return this.getYTitle(0);
+    }
+
+    public String getYTitle(int scale) {
+        return this.mYTitle[scale];
+    }
+
+    public void setYTitle(String title) {
+        this.setYTitle(title, 0);
+    }
+
+    public void setYTitle(String title, int scale) {
+        this.mYTitle[scale] = title;
+    }
+
+    public float getAxisTitleTextSize() {
+        return this.mAxisTitleTextSize;
+    }
+
+    public void setAxisTitleTextSize(float textSize) {
+        this.mAxisTitleTextSize = textSize;
+    }
+
+    public double getXAxisMin() {
+        return this.getXAxisMin(0);
+    }
+
+    public void setXAxisMin(double min) {
+        this.setXAxisMin(min, 0);
+    }
+
+    public boolean isMinXSet() {
+        return this.isMinXSet(0);
+    }
+
+    public double getXAxisMax() {
+        return this.getXAxisMax(0);
+    }
+
+    public void setXAxisMax(double max) {
+        this.setXAxisMax(max, 0);
+    }
+
+    public boolean isMaxXSet() {
+        return this.isMaxXSet(0);
+    }
+
+    public double getYAxisMin() {
+        return this.getYAxisMin(0);
+    }
+
+    public void setYAxisMin(double min) {
+        this.setYAxisMin(min, 0);
+    }
+
+    public boolean isMinYSet() {
+        return this.isMinYSet(0);
+    }
+
+    public double getYAxisMax() {
+        return this.getYAxisMax(0);
+    }
+
+    public void setYAxisMax(double max) {
+        this.setYAxisMax(max, 0);
+    }
+
+    public boolean isMaxYSet() {
+        return this.isMaxYSet(0);
+    }
+
+    public double getXAxisMin(int scale) {
+        return this.mMinX[scale];
+    }
+
+    public void setXAxisMin(double min, int scale) {
+        if (!this.isMinXSet(scale)) {
+            ((double[]) this.initialRange.get(scale))[0] = min;
+        }
+
+        this.mMinX[scale] = min;
+    }
+
+    public boolean isMinXSet(int scale) {
+        return this.mMinX[scale] != 1.7976931348623157E308D;
+    }
+
+    public double getXAxisMax(int scale) {
+        return this.mMaxX[scale];
+    }
+
+    public void setXAxisMax(double max, int scale) {
+        if (!this.isMaxXSet(scale)) {
+            ((double[]) this.initialRange.get(scale))[1] = max;
+        }
+
+        this.mMaxX[scale] = max;
+    }
+
+    public boolean isMaxXSet(int scale) {
+        return this.mMaxX[scale] != -1.7976931348623157E308D;
+    }
+
+    public double getYAxisMin(int scale) {
+        return this.mMinY[scale];
+    }
+
+    public void setYAxisMin(double min, int scale) {
+        if (!this.isMinYSet(scale)) {
+            ((double[]) this.initialRange.get(scale))[2] = min;
+        }
+
+        this.mMinY[scale] = min;
+    }
+
+    public boolean isMinYSet(int scale) {
+        return this.mMinY[scale] != 1.7976931348623157E308D;
+    }
+
+    public double getYAxisMax(int scale) {
+        return this.mMaxY[scale];
+    }
+
+    public void setYAxisMax(double max, int scale) {
+        if (!this.isMaxYSet(scale)) {
+            ((double[]) this.initialRange.get(scale))[3] = max;
+        }
+
+        this.mMaxY[scale] = max;
+    }
+
+    public boolean isMaxYSet(int scale) {
+        return this.mMaxY[scale] != -1.7976931348623157E308D;
+    }
+
+    public int getXLabels() {
+        return this.mXLabels;
+    }
+
+    public void setXLabels(int xLabels) {
+        this.mXLabels = xLabels;
+    }
+
+    /**
+     * @deprecated
+     */
+    public void addTextLabel(double x, String text) {
+        this.addXTextLabel(x, text);
+    }
+
+    public synchronized void addXTextLabel(double x, String text) {
+        this.mXTextLabels.put(x, text);
+    }
+
+    public synchronized void removeXTextLabel(double x) {
+        this.mXTextLabels.remove(x);
+    }
+
+    public synchronized String getXTextLabel(Double x) {
+        return (String) this.mXTextLabels.get(x);
+    }
+
+    public synchronized Double[] getXTextLabelLocations() {
+        return (Double[]) this.mXTextLabels.keySet().toArray(new Double[0]);
+    }
+
+    /**
+     * @deprecated
+     */
+    public void clearTextLabels() {
+        this.clearXTextLabels();
+    }
+
+    public synchronized void clearXTextLabels() {
+        this.mXTextLabels.clear();
+    }
+
+    public boolean isXRoundedLabels() {
+        return this.mXRoundedLabels;
+    }
+
+    public void setXRoundedLabels(boolean rounded) {
+        this.mXRoundedLabels = rounded;
+    }
+
+    public void addYTextLabel(double y, String text) {
+        this.addYTextLabel(y, text, 0);
+    }
+
+    public void removeYTextLabel(double y) {
+        this.removeYTextLabel(y, 0);
+    }
+
+    public synchronized void addYTextLabel(double y, String text, int scale) {
+        ((Map) this.mYTextLabels.get(scale)).put(y, text);
+    }
+
+    public synchronized void removeYTextLabel(double y, int scale) {
+        ((Map) this.mYTextLabels.get(scale)).remove(y);
+    }
+
+    public String getYTextLabel(Double y) {
+        return this.getYTextLabel(y, 0);
+    }
+
+    public synchronized String getYTextLabel(Double y, int scale) {
+        return (String) ((Map) this.mYTextLabels.get(scale)).get(y);
+    }
+
+    public Double[] getYTextLabelLocations() {
+        return this.getYTextLabelLocations(0);
+    }
+
+    public synchronized Double[] getYTextLabelLocations(int scale) {
+        return (Double[]) ((Map) this.mYTextLabels.get(scale)).keySet().toArray(new Double[0]);
+    }
+
+    public void clearYTextLabels() {
+        this.clearYTextLabels(0);
+    }
+
+    public synchronized void clearYTextLabels(int scale) {
+        ((Map) this.mYTextLabels.get(scale)).clear();
+    }
+
+    public int getYLabels() {
+        return this.mYLabels;
+    }
+
+    public void setYLabels(int yLabels) {
+        this.mYLabels = yLabels;
+    }
+
+    public float getBarWidth() {
+        return this.mBarWidth;
+    }
+
+    public void setBarWidth(float width) {
+        this.mBarWidth = width;
+    }
+
+    public boolean isPanEnabled() {
+        return this.isPanXEnabled() || this.isPanYEnabled();
+    }
+
+    public boolean isPanXEnabled() {
+        return this.mPanXEnabled;
+    }
+
+    public boolean isPanYEnabled() {
+        return this.mPanYEnabled;
+    }
+
+    public void setPanEnabled(boolean enabledX, boolean enabledY) {
+        this.mPanXEnabled = enabledX;
+        this.mPanYEnabled = enabledY;
+    }
+
+    public void setPanEnabled(boolean enabled) {
+        this.setPanEnabled(enabled, enabled);
+    }
+
+    public boolean isZoomEnabled() {
+        return this.isZoomXEnabled() || this.isZoomYEnabled();
+    }
+
+    public boolean isZoomXEnabled() {
+        return this.mZoomXEnabled;
+    }
+
+    public boolean isZoomYEnabled() {
+        return this.mZoomYEnabled;
+    }
+
+    public void setZoomEnabled(boolean enabledX, boolean enabledY) {
+        this.mZoomXEnabled = enabledX;
+        this.mZoomYEnabled = enabledY;
+    }
+
+    /**
+     * @deprecated
+     */
+    public double getBarsSpacing() {
+        return this.getBarSpacing();
+    }
+
+    public double getBarSpacing() {
+        return this.mBarSpacing;
+    }
+
+    public void setBarSpacing(double spacing) {
+        this.mBarSpacing = spacing;
+    }
+
+    public int getMarginsColor() {
+        return this.mMarginsColor;
+    }
+
+    public void setMarginsColor(int color) {
+        this.mMarginsColor = color;
+    }
+
+    public int getGridColor(int scale) {
+        return this.mGridColors[scale];
+    }
+
+    public void setGridColor(int color) {
+        this.setGridColor(color, 0);
+    }
+
+    public void setGridColor(int color, int scale) {
+        this.mGridColors[scale] = color;
+    }
+
+    public double[] getPanLimits() {
+        return this.mPanLimits;
+    }
+
+    public void setPanLimits(double[] panLimits) {
+        this.mPanLimits = panLimits;
+    }
+
+    public double[] getZoomLimits() {
+        return this.mZoomLimits;
+    }
+
+    public void setZoomLimits(double[] zoomLimits) {
+        this.mZoomLimits = zoomLimits;
+    }
+
+    public float getXLabelsAngle() {
+        return this.mXLabelsAngle;
+    }
+
+    public void setXLabelsAngle(float angle) {
+        this.mXLabelsAngle = angle;
+    }
+
+    public float getYLabelsAngle() {
+        return this.mYLabelsAngle;
+    }
+
+    public void setYLabelsAngle(float angle) {
+        this.mYLabelsAngle = angle;
+    }
+
+    public float getPointSize() {
+        return this.mPointSize;
+    }
+
+    public void setPointSize(float size) {
+        this.mPointSize = size;
+    }
+
+    public void setRange(double[] range) {
+        this.setRange(range, 0);
+    }
+
+    public void setRange(double[] range, int scale) {
+        this.setXAxisMin(range[0], scale);
+        this.setXAxisMax(range[1], scale);
+        this.setYAxisMin(range[2], scale);
+        this.setYAxisMax(range[3], scale);
+    }
+
+    public boolean isInitialRangeSet() {
+        return this.isInitialRangeSet(0);
+    }
+
+    public boolean isInitialRangeSet(int scale) {
+        return this.initialRange.get(scale) != null;
+    }
+
+    public double[] getInitialRange() {
+        return this.getInitialRange(0);
+    }
+
+    public double[] getInitialRange(int scale) {
+        return (double[]) this.initialRange.get(scale);
+    }
+
+    public void setInitialRange(double[] range) {
+        this.setInitialRange(range, 0);
+    }
+
+    public void setInitialRange(double[] range, int scale) {
+        this.initialRange.put(scale, range);
+    }
+
+    public int getXLabelsColor() {
+        return this.mXLabelsColor;
+    }
+
+    public int getYLabelsColor(int scale) {
+        return this.mYLabelsColor[scale];
+    }
+
+    public void setXLabelsColor(int color) {
+        this.mXLabelsColor = color;
+    }
+
+    public void setYLabelsColor(int scale, int color) {
+        this.mYLabelsColor[scale] = color;
+    }
+
+    public Align getXLabelsAlign() {
+        return this.xLabelsAlign;
+    }
+
+    public void setXLabelsAlign(Align align) {
+        this.xLabelsAlign = align;
+    }
+
+    public Align getYLabelsAlign(int scale) {
+        return this.yLabelsAlign[scale];
+    }
+
+    public void setYLabelsAlign(Align align) {
+        this.setYLabelsAlign(align, 0);
+    }
+
+    public Align getYAxisAlign(int scale) {
+        return this.yAxisAlign[scale];
+    }
+
+    public void setYAxisAlign(Align align, int scale) {
+        this.yAxisAlign[scale] = align;
+    }
+
+    public void setYLabelsAlign(Align align, int scale) {
+        this.yLabelsAlign[scale] = align;
+    }
+
+    public float getXLabelsPadding() {
+        return this.mXLabelsPadding;
+    }
+
+    public void setXLabelsPadding(float padding) {
+        this.mXLabelsPadding = padding;
+    }
+
+    public float getYLabelsPadding() {
+        return this.mYLabelsPadding;
+    }
+
+    public void setYLabelsVerticalPadding(float padding) {
+        this.mYLabelsVerticalPadding = padding;
+    }
+
+    public float getYLabelsVerticalPadding() {
+        return this.mYLabelsVerticalPadding;
+    }
+
+    public void setYLabelsPadding(float padding) {
+        this.mYLabelsPadding = padding;
+    }
+
+    /**
+     * @deprecated
+     */
+    public NumberFormat getLabelFormat() {
+        return this.getXLabelFormat();
+    }
+
+    /**
+     * @deprecated
+     */
+    public void setLabelFormat(NumberFormat format) {
+        this.setXLabelFormat(format);
+    }
+
+    public NumberFormat getXLabelFormat() {
+        return this.mXLabelFormat;
+    }
+
+    public void setXLabelFormat(NumberFormat format) {
+        this.mXLabelFormat = format;
+    }
+
+    public NumberFormat getYLabelFormat(int scale) {
+        return this.mYLabelFormat[scale];
+    }
+
+    public void setYLabelFormat(NumberFormat format, int scale) {
+        this.mYLabelFormat[scale] = format;
+    }
+
+    public double getZoomInLimitX() {
+        return this.mZoomInLimitX;
+    }
+
+    public void setZoomInLimitX(double zoomInLimitX) {
+        this.mZoomInLimitX = zoomInLimitX;
+    }
+
+    public double getZoomInLimitY() {
+        return this.mZoomInLimitY;
+    }
+
+    public void setZoomInLimitY(double zoomInLimitY) {
+        this.mZoomInLimitY = zoomInLimitY;
+    }
+
+    public int getScalesCount() {
+        return this.scalesCount;
+    }
+
+    public static enum Orientation {
+        HORIZONTAL(0),
+        VERTICAL(90);
+
+        private int mAngle = 0;
+
+        private Orientation(int angle) {
+            this.mAngle = angle;
+        }
+
+        public int getAngle() {
+            return this.mAngle;
+        }
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/model/SeriesSelection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/model/SeriesSelection.java	(date 1580288960000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/model/SeriesSelection.java	(date 1580288960000)
@@ -0,0 +1,36 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.model;
+
+public class SeriesSelection {
+    private int mSeriesIndex;
+    private int mPointIndex;
+    private double mXValue;
+    private double mValue;
+
+    public SeriesSelection(int seriesIndex, int pointIndex, double xValue, double value) {
+        this.mSeriesIndex = seriesIndex;
+        this.mPointIndex = pointIndex;
+        this.mXValue = xValue;
+        this.mValue = value;
+    }
+
+    public int getSeriesIndex() {
+        return this.mSeriesIndex;
+    }
+
+    public int getPointIndex() {
+        return this.mPointIndex;
+    }
+
+    public double getXValue() {
+        return this.mXValue;
+    }
+
+    public double getValue() {
+        return this.mValue;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/model/Point.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/model/Point.java	(date 1580288887000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/model/Point.java	(date 1580288887000)
@@ -0,0 +1,37 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.model;
+
+import java.io.Serializable;
+
+public final class Point implements Serializable {
+    private float mX;
+    private float mY;
+
+    public Point() {
+    }
+
+    public Point(float x, float y) {
+        this.mX = x;
+        this.mY = y;
+    }
+
+    public float getX() {
+        return this.mX;
+    }
+
+    public float getY() {
+        return this.mY;
+    }
+
+    public void setX(float x) {
+        this.mX = x;
+    }
+
+    public void setY(float y) {
+        this.mY = y;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/InterfaceDrawChartStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/InterfaceDrawChartStrategy.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/chart/InterfaceDrawChartStrategy.java	(date 1580376426000)
@@ -4,10 +4,11 @@
 
 package www.jingkan.com.view.chart;
 
-import org.achartengine.util.IndexXYMap;
 
 import java.util.List;
 
+import www.jingkan.com.view.chart.achartengine.util.IndexXYMap;
+
 /**
  * Created by lushengbo on 2018/1/4.
  * 画图策略
Index: app/src/main/java/www/jingkan/com/view/chart/DoubleBridgeMultifunctionStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/DoubleBridgeMultifunctionStrategy.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/chart/DoubleBridgeMultifunctionStrategy.java	(date 1580376425000)
@@ -8,13 +8,15 @@
 import android.graphics.Color;
 import android.widget.RelativeLayout;
 
-import org.achartengine.chart.PointStyle;
-import org.achartengine.model.XYSeries;
-import org.achartengine.renderer.XYSeriesRenderer;
-import org.achartengine.util.IndexXYMap;
+
 
 import java.util.List;
 
+import www.jingkan.com.view.chart.achartengine.chart.PointStyle;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.util.IndexXYMap;
+
 /**
  * Created by lushengbo on 2018/1/4.
  * 算桥多功能试验绘图
Index: app/src/main/java/www/jingkan/com/view/chart/SingleBridgeMuStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/SingleBridgeMuStrategy.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/chart/SingleBridgeMuStrategy.java	(date 1580376425000)
@@ -8,13 +8,13 @@
 import android.graphics.Color;
 import android.widget.RelativeLayout;
 
-import org.achartengine.chart.PointStyle;
-import org.achartengine.model.XYSeries;
-import org.achartengine.renderer.XYSeriesRenderer;
-import org.achartengine.util.IndexXYMap;
-
 import java.util.List;
 
+import www.jingkan.com.view.chart.achartengine.chart.PointStyle;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.util.IndexXYMap;
+
 /**
  * Created by lushengbo on 2018/1/4.
  * 单桥多功能绘图
Index: app/src/main/java/www/jingkan/com/view/chart/CalibrationStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/CalibrationStrategy.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/chart/CalibrationStrategy.java	(date 1580376425000)
@@ -8,9 +8,10 @@
 import android.graphics.Color;
 import android.widget.RelativeLayout;
 
-import org.achartengine.chart.PointStyle;
-import org.achartengine.model.XYSeries;
-import org.achartengine.renderer.XYSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.chart.PointStyle;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
 
 /**
  * Created by lushengbo on 2018/1/4.
Index: app/src/main/java/www/jingkan/com/view/chart/DoubleBridgeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/DoubleBridgeStrategy.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view/chart/DoubleBridgeStrategy.java	(date 1580376425000)
@@ -8,13 +8,15 @@
 import android.graphics.Color;
 import android.widget.RelativeLayout;
 
-import org.achartengine.chart.PointStyle;
-import org.achartengine.model.XYSeries;
-import org.achartengine.renderer.XYSeriesRenderer;
-import org.achartengine.util.IndexXYMap;
+
 
 import java.util.List;
 
+import www.jingkan.com.view.chart.achartengine.chart.PointStyle;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.util.IndexXYMap;
+
 /**
  * Created by lushengbo on 2018/1/4.
  * 双桥绘图类
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/build.gradle	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/build.gradle	(date 1580376425000)
@@ -105,7 +105,7 @@
     androidTestImplementation deps.support.app_compat
     androidTestImplementation deps.support.design
 
-    implementation files('libs/achartengine-1.2.0.jar')
+//    implementation files('libs/achartengine-1.2.0.jar')
     implementation files('libs/guava-r07.jar')
     implementation files('libs/additionnal.jar')
     implementation fileTree(include: ['*.jar'], dir: 'libs')
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/AbstractTool.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/AbstractTool.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/AbstractTool.java	(date 1580374307000)
@@ -0,0 +1,70 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.tools;
+
+
+import www.jingkan.com.view.chart.achartengine.chart.AbstractChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+
+public abstract class AbstractTool {
+    protected AbstractChart mChart;
+    protected XYMultipleSeriesRenderer mRenderer;
+
+    public AbstractTool(AbstractChart chart) {
+        this.mChart = chart;
+        if (chart instanceof XYChart) {
+            this.mRenderer = ((XYChart) chart).getRenderer();
+        }
+
+    }
+
+    public double[] getRange(int scale) {
+        double minX = this.mRenderer.getXAxisMin(scale);
+        double maxX = this.mRenderer.getXAxisMax(scale);
+        double minY = this.mRenderer.getYAxisMin(scale);
+        double maxY = this.mRenderer.getYAxisMax(scale);
+        return new double[]{minX, maxX, minY, maxY};
+    }
+
+    public void checkRange(double[] range, int scale) {
+        if (this.mChart instanceof XYChart) {
+            double[] calcRange = ((XYChart) this.mChart).getCalcRange(scale);
+            if (calcRange != null) {
+                if (!this.mRenderer.isMinXSet(scale)) {
+                    range[0] = calcRange[0];
+                    this.mRenderer.setXAxisMin(range[0], scale);
+                }
+
+                if (!this.mRenderer.isMaxXSet(scale)) {
+                    range[1] = calcRange[1];
+                    this.mRenderer.setXAxisMax(range[1], scale);
+                }
+
+                if (!this.mRenderer.isMinYSet(scale)) {
+                    range[2] = calcRange[2];
+                    this.mRenderer.setYAxisMin(range[2], scale);
+                }
+
+                if (!this.mRenderer.isMaxYSet(scale)) {
+                    range[3] = calcRange[3];
+                    this.mRenderer.setYAxisMax(range[3], scale);
+                }
+            }
+        }
+
+    }
+
+    protected void setXRange(double min, double max, int scale) {
+        this.mRenderer.setXAxisMin(min, scale);
+        this.mRenderer.setXAxisMax(max, scale);
+    }
+
+    protected void setYRange(double min, double max, int scale) {
+        this.mRenderer.setYAxisMin(min, scale);
+        this.mRenderer.setYAxisMax(max, scale);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/Zoom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/Zoom.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/Zoom.java	(date 1580374307000)
@@ -0,0 +1,140 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.tools;
+
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.chart.AbstractChart;
+import www.jingkan.com.view.chart.achartengine.chart.RoundChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+
+public class Zoom extends AbstractTool {
+    private boolean mZoomIn;
+    private float mZoomRate;
+    private List<ZoomListener> mZoomListeners = new ArrayList();
+    private boolean limitsReachedX = false;
+    private boolean limitsReachedY = false;
+    public static final int ZOOM_AXIS_XY = 0;
+    public static final int ZOOM_AXIS_X = 1;
+    public static final int ZOOM_AXIS_Y = 2;
+
+    public Zoom(AbstractChart chart, boolean in, float rate) {
+        super(chart);
+        this.mZoomIn = in;
+        this.setZoomRate(rate);
+    }
+
+    public void setZoomRate(float rate) {
+        this.mZoomRate = rate;
+    }
+
+    public void apply(int zoom_axis) {
+        if (this.mChart instanceof XYChart) {
+            int scales = this.mRenderer.getScalesCount();
+
+            for (int i = 0; i < scales; ++i) {
+                double[] range = this.getRange(i);
+                this.checkRange(range, i);
+                double[] limits = this.mRenderer.getZoomLimits();
+                double centerX = (range[0] + range[1]) / 2.0D;
+                double centerY = (range[2] + range[3]) / 2.0D;
+                double newWidth = range[1] - range[0];
+                double newHeight = range[3] - range[2];
+                double newXMin = centerX - newWidth / 2.0D;
+                double newXMax = centerX + newWidth / 2.0D;
+                double newYMin = centerY - newHeight / 2.0D;
+                double newYMax = centerY + newHeight / 2.0D;
+                if (i == 0) {
+                    this.limitsReachedX = limits != null && (newXMin <= limits[0] || newXMax >= limits[1]);
+                    this.limitsReachedY = limits != null && (newYMin <= limits[2] || newYMax >= limits[3]);
+                }
+
+                if (this.mZoomIn) {
+                    if (this.mRenderer.isZoomXEnabled() && (zoom_axis == 1 || zoom_axis == 0) && (!this.limitsReachedX || this.mZoomRate >= 1.0F)) {
+                        newWidth /= (double) this.mZoomRate;
+                    }
+
+                    if (this.mRenderer.isZoomYEnabled() && (zoom_axis == 2 || zoom_axis == 0) && (!this.limitsReachedY || this.mZoomRate >= 1.0F)) {
+                        newHeight /= (double) this.mZoomRate;
+                    }
+                } else {
+                    if (this.mRenderer.isZoomXEnabled() && !this.limitsReachedX && (zoom_axis == 1 || zoom_axis == 0)) {
+                        newWidth *= (double) this.mZoomRate;
+                    }
+
+                    if (this.mRenderer.isZoomYEnabled() && !this.limitsReachedY && (zoom_axis == 2 || zoom_axis == 0)) {
+                        newHeight *= (double) this.mZoomRate;
+                    }
+                }
+
+                double minX;
+                double minY;
+                if (limits != null) {
+                    minX = Math.min(this.mRenderer.getZoomInLimitX(), limits[1] - limits[0]);
+                    minY = Math.min(this.mRenderer.getZoomInLimitY(), limits[3] - limits[2]);
+                } else {
+                    minX = this.mRenderer.getZoomInLimitX();
+                    minY = this.mRenderer.getZoomInLimitY();
+                }
+
+                newWidth = Math.max(newWidth, minX);
+                newHeight = Math.max(newHeight, minY);
+                if (this.mRenderer.isZoomXEnabled() && (zoom_axis == 1 || zoom_axis == 0)) {
+                    newXMin = centerX - newWidth / 2.0D;
+                    newXMax = centerX + newWidth / 2.0D;
+                    this.setXRange(newXMin, newXMax, i);
+                }
+
+                if (this.mRenderer.isZoomYEnabled() && (zoom_axis == 2 || zoom_axis == 0)) {
+                    newYMin = centerY - newHeight / 2.0D;
+                    newYMax = centerY + newHeight / 2.0D;
+                    this.setYRange(newYMin, newYMax, i);
+                }
+            }
+        } else {
+            DefaultRenderer renderer = ((RoundChart) this.mChart).getRenderer();
+            if (this.mZoomIn) {
+                renderer.setScale(renderer.getScale() * this.mZoomRate);
+            } else {
+                renderer.setScale(renderer.getScale() / this.mZoomRate);
+            }
+        }
+
+        this.notifyZoomListeners(new ZoomEvent(this.mZoomIn, this.mZoomRate));
+    }
+
+    private synchronized void notifyZoomListeners(ZoomEvent e) {
+        Iterator i$ = this.mZoomListeners.iterator();
+
+        while (i$.hasNext()) {
+            ZoomListener listener = (ZoomListener) i$.next();
+            listener.zoomApplied(e);
+        }
+
+    }
+
+    public synchronized void notifyZoomResetListeners() {
+        Iterator i$ = this.mZoomListeners.iterator();
+
+        while (i$.hasNext()) {
+            ZoomListener listener = (ZoomListener) i$.next();
+            listener.zoomReset();
+        }
+
+    }
+
+    public synchronized void addZoomListener(ZoomListener listener) {
+        this.mZoomListeners.add(listener);
+    }
+
+    public synchronized void removeZoomListener(ZoomListener listener) {
+        this.mZoomListeners.remove(listener);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/ZoomEvent.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/ZoomEvent.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/ZoomEvent.java	(date 1580374307000)
@@ -0,0 +1,24 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.tools;
+
+public class ZoomEvent {
+    private boolean mZoomIn;
+    private float mZoomRate;
+
+    public ZoomEvent(boolean in, float rate) {
+        this.mZoomIn = in;
+        this.mZoomRate = rate;
+    }
+
+    public boolean isZoomIn() {
+        return this.mZoomIn;
+    }
+
+    public float getZoomRate() {
+        return this.mZoomRate;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/ZoomListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/ZoomListener.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/ZoomListener.java	(date 1580374307000)
@@ -0,0 +1,12 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.tools;
+
+public interface ZoomListener {
+    void zoomApplied(ZoomEvent var1);
+
+    void zoomReset();
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/model/CategorySeries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/model/CategorySeries.java	(date 1580294111000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/model/CategorySeries.java	(date 1580294111000)
@@ -0,0 +1,75 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.model;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class CategorySeries implements Serializable {
+    private String mTitle;
+    private List<String> mCategories = new ArrayList();
+    private List<Double> mValues = new ArrayList();
+
+    public CategorySeries(String title) {
+        this.mTitle = title;
+    }
+
+    public String getTitle() {
+        return this.mTitle;
+    }
+
+    public synchronized void add(double value) {
+        this.add(this.mCategories.size() + "", value);
+    }
+
+    public synchronized void add(String category, double value) {
+        this.mCategories.add(category);
+        this.mValues.add(value);
+    }
+
+    public synchronized void set(int index, String category, double value) {
+        this.mCategories.set(index, category);
+        this.mValues.set(index, value);
+    }
+
+    public synchronized void remove(int index) {
+        this.mCategories.remove(index);
+        this.mValues.remove(index);
+    }
+
+    public synchronized void clear() {
+        this.mCategories.clear();
+        this.mValues.clear();
+    }
+
+    public synchronized double getValue(int index) {
+        return (Double) this.mValues.get(index);
+    }
+
+    public synchronized String getCategory(int index) {
+        return (String) this.mCategories.get(index);
+    }
+
+    public synchronized int getItemCount() {
+        return this.mCategories.size();
+    }
+
+    public XYSeries toXYSeries() {
+        XYSeries xySeries = new XYSeries(this.mTitle);
+        int k = 0;
+        Iterator i$ = this.mValues.iterator();
+
+        while (i$.hasNext()) {
+            double value = (Double) i$.next();
+            ++k;
+            xySeries.add((double) k, value);
+        }
+
+        return xySeries;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RoundChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RoundChart.java	(date 1580294111000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RoundChart.java	(date 1580294111000)
@@ -0,0 +1,66 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+
+import www.jingkan.com.view.chart.achartengine.model.CategorySeries;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+
+public abstract class RoundChart extends AbstractChart {
+    protected static final int SHAPE_WIDTH = 10;
+    protected CategorySeries mDataset;
+    protected DefaultRenderer mRenderer;
+    protected static final int NO_VALUE = 2147483647;
+    protected int mCenterX = 2147483647;
+    protected int mCenterY = 2147483647;
+
+    public RoundChart(CategorySeries dataset, DefaultRenderer renderer) {
+        this.mDataset = dataset;
+        this.mRenderer = renderer;
+    }
+
+    public void drawTitle(Canvas canvas, int x, int y, int width, Paint paint) {
+        if (this.mRenderer.isShowLabels()) {
+            paint.setColor(this.mRenderer.getLabelsColor());
+            paint.setTextAlign(Align.CENTER);
+            paint.setTextSize(this.mRenderer.getChartTitleTextSize());
+            this.drawString(canvas, this.mRenderer.getChartTitle(), (float) (x + width / 2), (float) y + this.mRenderer.getChartTitleTextSize(), paint);
+        }
+
+    }
+
+    public int getLegendShapeWidth(int seriesIndex) {
+        return 10;
+    }
+
+    public void drawLegendShape(Canvas canvas, SimpleSeriesRenderer renderer, float x, float y, int seriesIndex, Paint paint) {
+        canvas.drawRect(x, y - 5.0F, x + 10.0F, y + 5.0F, paint);
+    }
+
+    public DefaultRenderer getRenderer() {
+        return this.mRenderer;
+    }
+
+    public int getCenterX() {
+        return this.mCenterX;
+    }
+
+    public int getCenterY() {
+        return this.mCenterY;
+    }
+
+    public void setCenterX(int centerX) {
+        this.mCenterX = centerX;
+    }
+
+    public void setCenterY(int centerY) {
+        this.mCenterY = centerY;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/BubbleChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/BubbleChart.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/BubbleChart.java	(date 1580374307000)
@@ -0,0 +1,80 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.RectF;
+
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.model.XYValueSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
+public class BubbleChart extends XYChart {
+    public static final String TYPE = "Bubble";
+    private static final int SHAPE_WIDTH = 10;
+    private static final int MIN_BUBBLE_SIZE = 2;
+    private static final int MAX_BUBBLE_SIZE = 20;
+
+    BubbleChart() {
+    }
+
+    public BubbleChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        super(dataset, renderer);
+    }
+
+    public void drawSeries(Canvas canvas, Paint paint, List<Float> points, XYSeriesRenderer renderer, float yAxisValue, int seriesIndex, int startIndex) {
+        paint.setColor(renderer.getColor());
+        paint.setStyle(Style.FILL);
+        int length = points.size();
+        XYValueSeries series = (XYValueSeries) this.mDataset.getSeriesAt(seriesIndex);
+        double max = series.getMaxValue();
+        double coef = 20.0D / max;
+
+        for (int i = 0; i < length; i += 2) {
+            double size = series.getValue(startIndex + i / 2) * coef + 2.0D;
+            this.drawCircle(canvas, paint, (Float) points.get(i), (Float) points.get(i + 1), (float) size);
+        }
+
+    }
+
+    protected ClickableArea[] clickableAreasForPoints(List<Float> points, List<Double> values, float yAxisValue, int seriesIndex, int startIndex) {
+        int length = points.size();
+        XYValueSeries series = (XYValueSeries) this.mDataset.getSeriesAt(seriesIndex);
+        double max = series.getMaxValue();
+        double coef = 20.0D / max;
+        ClickableArea[] ret = new ClickableArea[length / 2];
+
+        for (int i = 0; i < length; i += 2) {
+            double size = series.getValue(startIndex + i / 2) * coef + 2.0D;
+            ret[i / 2] = new ClickableArea(new RectF((Float) points.get(i) - (float) size, (Float) points.get(i + 1) - (float) size, (Float) points.get(i) + (float) size, (Float) points.get(i + 1) + (float) size), (Double) values.get(i), (Double) values.get(i + 1));
+        }
+
+        return ret;
+    }
+
+    public int getLegendShapeWidth(int seriesIndex) {
+        return 10;
+    }
+
+    public void drawLegendShape(Canvas canvas, SimpleSeriesRenderer renderer, float x, float y, int seriesIndex, Paint paint) {
+        paint.setStyle(Style.FILL);
+        this.drawCircle(canvas, paint, x + 10.0F, y, 3.0F);
+    }
+
+    private void drawCircle(Canvas canvas, Paint paint, float x, float y, float radius) {
+        canvas.drawCircle(x, y, radius, paint);
+    }
+
+    public String getChartType() {
+        return "Bubble";
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/BarChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/BarChart.java	(date 1580294111000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/BarChart.java	(date 1580294111000)
@@ -0,0 +1,243 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.RectF;
+import android.graphics.drawable.GradientDrawable;
+import android.graphics.drawable.GradientDrawable.Orientation;
+
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
+public class BarChart extends XYChart {
+    public static final String TYPE = "Bar";
+    private static final int SHAPE_WIDTH = 12;
+    protected BarChart.Type mType;
+    private List<Float> mPreviousSeriesPoints;
+
+    BarChart() {
+        this.mType = BarChart.Type.DEFAULT;
+    }
+
+    BarChart(BarChart.Type type) {
+        this.mType = BarChart.Type.DEFAULT;
+        this.mType = type;
+    }
+
+    public BarChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, BarChart.Type type) {
+        super(dataset, renderer);
+        this.mType = BarChart.Type.DEFAULT;
+        this.mType = type;
+    }
+
+    protected ClickableArea[] clickableAreasForPoints(List<Float> points, List<Double> values, float yAxisValue, int seriesIndex, int startIndex) {
+        int seriesNr = this.mDataset.getSeriesCount();
+        int length = points.size();
+        ClickableArea[] ret = new ClickableArea[length / 2];
+        float halfDiffX = this.getHalfDiffX(points, length, seriesNr);
+
+        for (int i = 0; i < length; i += 2) {
+            float x = (Float) points.get(i);
+            float y = (Float) points.get(i + 1);
+            if (this.mType != BarChart.Type.STACKED && this.mType != BarChart.Type.HEAPED) {
+                float startX = x - (float) seriesNr * halfDiffX + (float) (seriesIndex * 2) * halfDiffX;
+                ret[i / 2] = new ClickableArea(new RectF(startX, Math.min(y, yAxisValue), startX + 2.0F * halfDiffX, Math.max(y, yAxisValue)), (Double) values.get(i), (Double) values.get(i + 1));
+            } else {
+                ret[i / 2] = new ClickableArea(new RectF(x - halfDiffX, Math.min(y, yAxisValue), x + halfDiffX, Math.max(y, yAxisValue)), (Double) values.get(i), (Double) values.get(i + 1));
+            }
+        }
+
+        return ret;
+    }
+
+    public void drawSeries(Canvas canvas, Paint paint, List<Float> points, XYSeriesRenderer seriesRenderer, float yAxisValue, int seriesIndex, int startIndex) {
+        int seriesNr = this.mDataset.getSeriesCount();
+        int length = points.size();
+        paint.setColor(seriesRenderer.getColor());
+        paint.setStyle(Style.FILL);
+        float halfDiffX = this.getHalfDiffX(points, length, seriesNr);
+
+        for (int i = 0; i < length; i += 2) {
+            float x = (Float) points.get(i);
+            float y = (Float) points.get(i + 1);
+            if (this.mType == BarChart.Type.HEAPED && seriesIndex > 0) {
+                float lastY = (Float) this.mPreviousSeriesPoints.get(i + 1);
+                y += lastY - yAxisValue;
+                points.set(i + 1, y);
+                this.drawBar(canvas, x, lastY, x, y, halfDiffX, seriesNr, seriesIndex, paint);
+            } else {
+                this.drawBar(canvas, x, yAxisValue, x, y, halfDiffX, seriesNr, seriesIndex, paint);
+            }
+        }
+
+        paint.setColor(seriesRenderer.getColor());
+        this.mPreviousSeriesPoints = points;
+    }
+
+    protected void drawBar(Canvas canvas, float xMin, float yMin, float xMax, float yMax, float halfDiffX, int seriesNr, int seriesIndex, Paint paint) {
+        int scale = this.mDataset.getSeriesAt(seriesIndex).getScaleNumber();
+        if (this.mType != BarChart.Type.STACKED && this.mType != BarChart.Type.HEAPED) {
+            float startX = xMin - (float) seriesNr * halfDiffX + (float) (seriesIndex * 2) * halfDiffX;
+            this.drawBar(canvas, startX, yMax, startX + 2.0F * halfDiffX, yMin, scale, seriesIndex, paint);
+        } else {
+            this.drawBar(canvas, xMin - halfDiffX, yMax, xMax + halfDiffX, yMin, scale, seriesIndex, paint);
+        }
+
+    }
+
+    protected void drawBar(Canvas canvas, float xMin, float yMin, float xMax, float yMax, int scale, int seriesIndex, Paint paint) {
+        float temp;
+        if (xMin > xMax) {
+            temp = xMin;
+            xMin = xMax;
+            xMax = temp;
+        }
+
+        if (yMin > yMax) {
+            temp = yMin;
+            yMin = yMax;
+            yMax = temp;
+        }
+
+        SimpleSeriesRenderer renderer = this.mRenderer.getSeriesRendererAt(seriesIndex);
+        if (renderer.isGradientEnabled()) {
+            float minY = (float) this.toScreenPoint(new double[]{0.0D, renderer.getGradientStopValue()}, scale)[1];
+            float maxY = (float) this.toScreenPoint(new double[]{0.0D, renderer.getGradientStartValue()}, scale)[1];
+            float gradientMinY = Math.max(minY, Math.min(yMin, yMax));
+            float gradientMaxY = Math.min(maxY, Math.max(yMin, yMax));
+            int gradientMinColor = renderer.getGradientStopColor();
+            int gradientMaxColor = renderer.getGradientStartColor();
+            int gradientStartColor = gradientMaxColor;
+            int gradientStopColor = gradientMinColor;
+            if (yMin < minY) {
+                paint.setColor(gradientMinColor);
+                canvas.drawRect((float) Math.round(xMin), (float) Math.round(yMin), (float) Math.round(xMax), (float) Math.round(gradientMinY), paint);
+            } else {
+                gradientStopColor = this.getGradientPartialColor(gradientMinColor, gradientMaxColor, (maxY - gradientMinY) / (maxY - minY));
+            }
+
+            if (yMax > maxY) {
+                paint.setColor(gradientMaxColor);
+                canvas.drawRect((float) Math.round(xMin), (float) Math.round(gradientMaxY), (float) Math.round(xMax), (float) Math.round(yMax), paint);
+            } else {
+                gradientStartColor = this.getGradientPartialColor(gradientMaxColor, gradientMinColor, (gradientMaxY - minY) / (maxY - minY));
+            }
+
+            GradientDrawable gradient = new GradientDrawable(Orientation.BOTTOM_TOP, new int[]{gradientStartColor, gradientStopColor});
+            gradient.setBounds(Math.round(xMin), Math.round(gradientMinY), Math.round(xMax), Math.round(gradientMaxY));
+            gradient.draw(canvas);
+        } else {
+            if (Math.abs(yMin - yMax) < 1.0F) {
+                if (yMin < yMax) {
+                    yMax = yMin + 1.0F;
+                } else {
+                    yMax = yMin - 1.0F;
+                }
+            }
+
+            canvas.drawRect((float) Math.round(xMin), (float) Math.round(yMin), (float) Math.round(xMax), (float) Math.round(yMax), paint);
+        }
+
+    }
+
+    protected int getGradientPartialColor(int minColor, int maxColor, float fraction) {
+        int alpha = Math.round(fraction * (float) Color.alpha(minColor) + (1.0F - fraction) * (float) Color.alpha(maxColor));
+        int r = Math.round(fraction * (float) Color.red(minColor) + (1.0F - fraction) * (float) Color.red(maxColor));
+        int g = Math.round(fraction * (float) Color.green(minColor) + (1.0F - fraction) * (float) Color.green(maxColor));
+        int b = Math.round(fraction * (float) Color.blue(minColor) + (1.0F - fraction) * (float) Color.blue(maxColor));
+        return Color.argb(alpha, r, g, b);
+    }
+
+    protected void drawChartValuesText(Canvas canvas, XYSeries series, XYSeriesRenderer renderer, Paint paint, List<Float> points, int seriesIndex, int startIndex) {
+        int seriesNr = this.mDataset.getSeriesCount();
+        int length = points.size();
+        float halfDiffX = this.getHalfDiffX(points, length, seriesNr);
+
+        for (int i = 0; i < length; i += 2) {
+            int index = startIndex + i / 2;
+            double value = series.getY(index);
+            if (!this.isNullValue(value)) {
+                float x = (Float) points.get(i);
+                if (this.mType == BarChart.Type.DEFAULT) {
+                    x += (float) (seriesIndex * 2) * halfDiffX - ((float) seriesNr - 1.5F) * halfDiffX;
+                }
+
+                if (value >= 0.0D) {
+                    this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), value), x, (Float) points.get(i + 1) - renderer.getChartValuesSpacing(), paint, 0.0F);
+                } else {
+                    this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), value), x, (Float) points.get(i + 1) + renderer.getChartValuesTextSize() + renderer.getChartValuesSpacing() - 3.0F, paint, 0.0F);
+                }
+            }
+        }
+
+    }
+
+    public int getLegendShapeWidth(int seriesIndex) {
+        return 12;
+    }
+
+    public void drawLegendShape(Canvas canvas, SimpleSeriesRenderer renderer, float x, float y, int seriesIndex, Paint paint) {
+        float halfShapeWidth = 6.0F;
+        canvas.drawRect(x, y - halfShapeWidth, x + 12.0F, y + halfShapeWidth, paint);
+    }
+
+    protected float getHalfDiffX(List<Float> points, int length, int seriesNr) {
+        float barWidth = this.mRenderer.getBarWidth();
+        if (barWidth > 0.0F) {
+            return barWidth / 2.0F;
+        } else {
+            int div = length;
+            if (length > 2) {
+                div = length - 2;
+            }
+
+            float halfDiffX = ((Float) points.get(length - 2) - (Float) points.get(0)) / (float) div;
+            if (halfDiffX == 0.0F) {
+                halfDiffX = 10.0F;
+            }
+
+            if (this.mType != BarChart.Type.STACKED && this.mType != BarChart.Type.HEAPED) {
+                halfDiffX /= (float) seriesNr;
+            }
+
+            return (float) ((double) halfDiffX / ((double) this.getCoeficient() * (1.0D + this.mRenderer.getBarSpacing())));
+        }
+    }
+
+    protected float getCoeficient() {
+        return 1.0F;
+    }
+
+    protected boolean isRenderNullValues() {
+        return true;
+    }
+
+    public double getDefaultMinimum() {
+        return 0.0D;
+    }
+
+    public String getChartType() {
+        return "Bar";
+    }
+
+    public static enum Type {
+        DEFAULT,
+        STACKED,
+        HEAPED;
+
+        private Type() {
+        }
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/Pan.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/Pan.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/Pan.java	(date 1580374307000)
@@ -0,0 +1,124 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.tools;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.chart.AbstractChart;
+import www.jingkan.com.view.chart.achartengine.chart.RoundChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+
+public class Pan extends AbstractTool {
+    private List<PanListener> mPanListeners = new ArrayList();
+    private boolean limitsReachedX = false;
+    private boolean limitsReachedY = false;
+
+    public Pan(AbstractChart chart) {
+        super(chart);
+    }
+
+    public void apply(float oldX, float oldY, float newX, float newY) {
+        boolean notLimitedUp = true;
+        boolean notLimitedBottom = true;
+        boolean notLimitedLeft = true;
+        boolean notLimitedRight = true;
+        if (!(this.mChart instanceof XYChart)) {
+            RoundChart chart = (RoundChart) this.mChart;
+            chart.setCenterX(chart.getCenterX() + (int) (newX - oldX));
+            chart.setCenterY(chart.getCenterY() + (int) (newY - oldY));
+        } else {
+            int scales = this.mRenderer.getScalesCount();
+            double[] limits = this.mRenderer.getPanLimits();
+            boolean limited = limits != null && limits.length == 4;
+            XYChart chart = (XYChart) this.mChart;
+
+            for (int i = 0; i < scales; ++i) {
+                double[] range = this.getRange(i);
+                double[] calcRange = chart.getCalcRange(i);
+                if (this.limitsReachedX && this.limitsReachedY && (range[0] == range[1] && calcRange[0] == calcRange[1] || range[2] == range[3] && calcRange[2] == calcRange[3])) {
+                    return;
+                }
+
+                this.checkRange(range, i);
+                double[] realPoint = chart.toRealPoint(oldX, oldY, i);
+                double[] realPoint2 = chart.toRealPoint(newX, newY, i);
+                double deltaX = realPoint[0] - realPoint2[0];
+                double deltaY = realPoint[1] - realPoint2[1];
+                double ratio = this.getAxisRatio(range);
+                if (chart.isVertical(this.mRenderer)) {
+                    double newDeltaX = -deltaY * ratio;
+                    double newDeltaY = deltaX / ratio;
+                    deltaX = newDeltaX;
+                    deltaY = newDeltaY;
+                }
+
+                if (this.mRenderer.isPanXEnabled()) {
+                    if (limits != null) {
+                        if (notLimitedLeft) {
+                            notLimitedLeft = limits[0] <= range[0] + deltaX;
+                        }
+
+                        if (notLimitedRight) {
+                            notLimitedRight = limits[1] >= range[1] + deltaX;
+                        }
+                    }
+
+                    if (limited && (!notLimitedLeft || !notLimitedRight)) {
+                        this.limitsReachedX = true;
+                    } else {
+                        this.setXRange(range[0] + deltaX, range[1] + deltaX, i);
+                        this.limitsReachedX = false;
+                    }
+                }
+
+                if (this.mRenderer.isPanYEnabled()) {
+                    if (limits != null) {
+                        if (notLimitedBottom) {
+                            notLimitedBottom = limits[2] <= range[2] + deltaY;
+                        }
+
+                        if (notLimitedUp) {
+                            notLimitedUp = limits[3] >= range[3] + deltaY;
+                        }
+                    }
+
+                    if (limited && (!notLimitedBottom || !notLimitedUp)) {
+                        this.limitsReachedY = true;
+                    } else {
+                        this.setYRange(range[2] + deltaY, range[3] + deltaY, i);
+                        this.limitsReachedY = false;
+                    }
+                }
+            }
+        }
+
+        this.notifyPanListeners();
+    }
+
+    private double getAxisRatio(double[] range) {
+        return Math.abs(range[1] - range[0]) / Math.abs(range[3] - range[2]);
+    }
+
+    private synchronized void notifyPanListeners() {
+        Iterator i$ = this.mPanListeners.iterator();
+
+        while (i$.hasNext()) {
+            PanListener listener = (PanListener) i$.next();
+            listener.panApplied();
+        }
+
+    }
+
+    public synchronized void addPanListener(PanListener listener) {
+        this.mPanListeners.add(listener);
+    }
+
+    public synchronized void removePanListener(PanListener listener) {
+        this.mPanListeners.remove(listener);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/PanListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/PanListener.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/PanListener.java	(date 1580374307000)
@@ -0,0 +1,10 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.tools;
+
+public interface PanListener {
+    void panApplied();
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/FitZoom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/FitZoom.java	(date 1580374307000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/tools/FitZoom.java	(date 1580374307000)
@@ -0,0 +1,61 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.tools;
+
+
+import www.jingkan.com.view.chart.achartengine.chart.AbstractChart;
+import www.jingkan.com.view.chart.achartengine.chart.RoundChart;
+import www.jingkan.com.view.chart.achartengine.chart.XYChart;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+
+public class FitZoom extends AbstractTool {
+    public FitZoom(AbstractChart chart) {
+        super(chart);
+    }
+
+    public void apply() {
+        if (this.mChart instanceof XYChart) {
+            if (((XYChart) this.mChart).getDataset() == null) {
+                return;
+            }
+
+            int scales = this.mRenderer.getScalesCount();
+            if (this.mRenderer.isInitialRangeSet()) {
+                for (int i = 0; i < scales; ++i) {
+                    if (this.mRenderer.isInitialRangeSet(i)) {
+                        this.mRenderer.setRange(this.mRenderer.getInitialRange(i), i);
+                    }
+                }
+            } else {
+                XYSeries[] series = ((XYChart) this.mChart).getDataset().getSeries();
+                int length = series.length;
+                if (length > 0) {
+                    for (int i = 0; i < scales; ++i) {
+                        double[] range = new double[]{1.7976931348623157E308D, -1.7976931348623157E308D, 1.7976931348623157E308D, -1.7976931348623157E308D};
+
+                        for (int j = 0; j < length; ++j) {
+                            if (i == series[j].getScaleNumber()) {
+                                range[0] = Math.min(range[0], series[j].getMinX());
+                                range[1] = Math.max(range[1], series[j].getMaxX());
+                                range[2] = Math.min(range[2], series[j].getMinY());
+                                range[3] = Math.max(range[3], series[j].getMaxY());
+                            }
+                        }
+
+                        double marginX = Math.abs(range[1] - range[0]) / 40.0D;
+                        double marginY = Math.abs(range[3] - range[2]) / 40.0D;
+                        this.mRenderer.setRange(new double[]{range[0] - marginX, range[1] + marginX, range[2] - marginY, range[3] + marginY}, i);
+                    }
+                }
+            }
+        } else {
+            DefaultRenderer renderer = ((RoundChart) this.mChart).getRenderer();
+            renderer.setScale(renderer.getOriginalScale());
+        }
+
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/CombinedXYChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/CombinedXYChart.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/CombinedXYChart.java	(date 1580376425000)
@@ -0,0 +1,157 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+
+import java.io.Serializable;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
+public class CombinedXYChart extends XYChart {
+    private CombinedXYChart.XYCombinedChartDef[] chartDefinitions;
+    private XYChart[] mCharts;
+    private Class<?>[] xyChartTypes = new Class[]{TimeChart.class, LineChart.class, CubicLineChart.class, BarChart.class, BubbleChart.class, ScatterChart.class, RangeBarChart.class, RangeStackedBarChart.class};
+
+    public CombinedXYChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, CombinedXYChart.XYCombinedChartDef[] chartDefinitions) {
+        super(dataset, renderer);
+        this.chartDefinitions = chartDefinitions;
+        int length = chartDefinitions.length;
+        this.mCharts = new XYChart[length];
+
+        for (int i = 0; i < length; ++i) {
+            try {
+                this.mCharts[i] = this.getXYChart(chartDefinitions[i].getType());
+            } catch (Exception var12) {
+            }
+
+            if (this.mCharts[i] == null) {
+                throw new IllegalArgumentException("Unknown chart type " + chartDefinitions[i].getType());
+            }
+
+            XYMultipleSeriesDataset newDataset = new XYMultipleSeriesDataset();
+            XYMultipleSeriesRenderer newRenderer = new XYMultipleSeriesRenderer();
+            int[] arr$ = chartDefinitions[i].getSeriesIndex();
+            int len$ = arr$.length;
+
+            for (int i$ = 0; i$ < len$; ++i$) {
+                int seriesIndex = arr$[i$];
+                newDataset.addSeries(dataset.getSeriesAt(seriesIndex));
+                newRenderer.addSeriesRenderer(renderer.getSeriesRendererAt(seriesIndex));
+            }
+
+            newRenderer.setBarSpacing(renderer.getBarSpacing());
+            newRenderer.setPointSize(renderer.getPointSize());
+            this.mCharts[i].setDatasetRenderer(newDataset, newRenderer);
+        }
+
+    }
+
+    private XYChart getXYChart(String type) throws IllegalAccessException, InstantiationException {
+        XYChart chart = null;
+        int length = this.xyChartTypes.length;
+
+        for (int i = 0; i < length && chart == null; ++i) {
+            XYChart newChart = (XYChart) this.xyChartTypes[i].newInstance();
+            if (type.equals(newChart.getChartType())) {
+                chart = newChart;
+            }
+        }
+
+        return chart;
+    }
+
+    public void drawSeries(Canvas canvas, Paint paint, List<Float> points, XYSeriesRenderer seriesRenderer, float yAxisValue, int seriesIndex, int startIndex) {
+        XYChart chart = this.getXYChart(seriesIndex);
+        chart.setScreenR(this.getScreenR());
+        chart.setCalcRange(this.getCalcRange(this.mDataset.getSeriesAt(seriesIndex).getScaleNumber()), 0);
+        chart.drawSeries(canvas, paint, points, seriesRenderer, yAxisValue, this.getChartSeriesIndex(seriesIndex), startIndex);
+    }
+
+    protected ClickableArea[] clickableAreasForPoints(List<Float> points, List<Double> values, float yAxisValue, int seriesIndex, int startIndex) {
+        XYChart chart = this.getXYChart(seriesIndex);
+        return chart.clickableAreasForPoints(points, values, yAxisValue, this.getChartSeriesIndex(seriesIndex), startIndex);
+    }
+
+    protected void drawSeries(XYSeries series, Canvas canvas, Paint paint, List<Float> pointsList, XYSeriesRenderer seriesRenderer, float yAxisValue, int seriesIndex, XYMultipleSeriesRenderer.Orientation or, int startIndex) {
+        XYChart chart = this.getXYChart(seriesIndex);
+        chart.setScreenR(this.getScreenR());
+        chart.setCalcRange(this.getCalcRange(this.mDataset.getSeriesAt(seriesIndex).getScaleNumber()), 0);
+        chart.drawSeries(series, canvas, paint, pointsList, seriesRenderer, yAxisValue, this.getChartSeriesIndex(seriesIndex), or, startIndex);
+    }
+
+    public int getLegendShapeWidth(int seriesIndex) {
+        XYChart chart = this.getXYChart(seriesIndex);
+        return chart.getLegendShapeWidth(this.getChartSeriesIndex(seriesIndex));
+    }
+
+    public void drawLegendShape(Canvas canvas, SimpleSeriesRenderer renderer, float x, float y, int seriesIndex, Paint paint) {
+        XYChart chart = this.getXYChart(seriesIndex);
+        chart.drawLegendShape(canvas, renderer, x, y, this.getChartSeriesIndex(seriesIndex), paint);
+    }
+
+    public String getChartType() {
+        return "Combined";
+    }
+
+    private XYChart getXYChart(int seriesIndex) {
+        for (int i = 0; i < this.chartDefinitions.length; ++i) {
+            if (this.chartDefinitions[i].containsSeries(seriesIndex)) {
+                return this.mCharts[i];
+            }
+        }
+
+        throw new IllegalArgumentException("Unknown series with index " + seriesIndex);
+    }
+
+    private int getChartSeriesIndex(int seriesIndex) {
+        for (int i = 0; i < this.chartDefinitions.length; ++i) {
+            if (this.chartDefinitions[i].containsSeries(seriesIndex)) {
+                return this.chartDefinitions[i].getChartSeriesIndex(seriesIndex);
+            }
+        }
+
+        throw new IllegalArgumentException("Unknown series with index " + seriesIndex);
+    }
+
+    public static class XYCombinedChartDef implements Serializable {
+        private String type;
+        private int[] seriesIndex;
+
+        public XYCombinedChartDef(String type, int... seriesIndex) {
+            this.type = type;
+            this.seriesIndex = seriesIndex;
+        }
+
+        public boolean containsSeries(int seriesIndex) {
+            return this.getChartSeriesIndex(seriesIndex) >= 0;
+        }
+
+        public int getChartSeriesIndex(int seriesIndex) {
+            for (int i = 0; i < this.getSeriesIndex().length; ++i) {
+                if (this.seriesIndex[i] == seriesIndex) {
+                    return i;
+                }
+            }
+
+            return -1;
+        }
+
+        public String getType() {
+            return this.type;
+        }
+
+        public int[] getSeriesIndex() {
+            return this.seriesIndex;
+        }
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYValueSeries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYValueSeries.java	(date 1580377350000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/model/XYValueSeries.java	(date 1580377350000)
@@ -0,0 +1,72 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class XYValueSeries extends XYSeries {
+    private List<Double> mValue = new ArrayList();
+    private double mMinValue = 1.7976931348623157E308D;
+    private double mMaxValue = -1.7976931348623157E308D;
+
+    public XYValueSeries(String title) {
+        super(title);
+    }
+
+    public synchronized void add(double x, double y, double value) {
+        super.add(x, y);
+        this.mValue.add(value);
+        this.updateRange(value);
+    }
+
+    private void initRange() {
+        this.mMinValue = 1.7976931348623157E308D;
+        this.mMaxValue = -1.7976931348623157E308D;
+        int length = this.getItemCount();
+
+        for (int k = 0; k < length; ++k) {
+            this.updateRange(this.getValue(k));
+        }
+
+    }
+
+    private void updateRange(double value) {
+        this.mMinValue = Math.min(this.mMinValue, value);
+        this.mMaxValue = Math.max(this.mMaxValue, value);
+    }
+
+    public synchronized void add(double x, double y) {
+        this.add(x, y, 0.0D);
+    }
+
+    public synchronized void remove(int index) {
+        super.remove(index);
+        double removedValue = (Double) this.mValue.remove(index);
+        if (removedValue == this.mMinValue || removedValue == this.mMaxValue) {
+            this.initRange();
+        }
+
+    }
+
+    public synchronized void clear() {
+        super.clear();
+        this.mValue.clear();
+        this.initRange();
+    }
+
+    public synchronized double getValue(int index) {
+        return (Double) this.mValue.get(index);
+    }
+
+    public double getMinValue() {
+        return this.mMinValue;
+    }
+
+    public double getMaxValue() {
+        return this.mMaxValue;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/CubicLineChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/CubicLineChart.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/CubicLineChart.java	(date 1580376425000)
@@ -0,0 +1,118 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.PathMeasure;
+
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.Point;
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
+public class CubicLineChart extends LineChart {
+    public static final String TYPE = "Cubic";
+    private float mFirstMultiplier;
+    private float mSecondMultiplier;
+    private PathMeasure mPathMeasure;
+
+    public CubicLineChart() {
+        this.mFirstMultiplier = 0.33F;
+        this.mSecondMultiplier = 1.0F - this.mFirstMultiplier;
+    }
+
+    public CubicLineChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, float smoothness) {
+        super(dataset, renderer);
+        this.mFirstMultiplier = smoothness;
+        this.mSecondMultiplier = 1.0F - this.mFirstMultiplier;
+    }
+
+    protected void drawPath(Canvas canvas, List<Float> points, Paint paint, boolean circular) {
+        Path p = new Path();
+        float x = points.get(0);
+        float y = points.get(1);
+        p.moveTo(x, y);
+        int length = points.size();
+        if (circular) {
+            length -= 4;
+        }
+
+        Point p1 = new Point();
+        Point p2 = new Point();
+        Point p3 = new Point();
+
+        int i;
+        for (i = 0; i < length; i += 2) {
+            int nextIndex = i + 2 < length ? i + 2 : i;
+            int nextNextIndex = i + 4 < length ? i + 4 : nextIndex;
+            this.calc(points, p1, i, nextIndex, this.mSecondMultiplier);
+            p2.setX(points.get(nextIndex));
+            p2.setY(points.get(nextIndex + 1));
+            this.calc(points, p3, nextIndex, nextNextIndex, this.mFirstMultiplier);
+            p.cubicTo(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());
+        }
+
+        this.mPathMeasure = new PathMeasure(p, false);
+        if (circular) {
+            for (i = length; i < length + 4; i += 2) {
+                p.lineTo(points.get(i), points.get(i + 1));
+            }
+
+            p.lineTo(points.get(0), points.get(1));
+        }
+
+        canvas.drawPath(p, paint);
+    }
+
+    private void calc(List<Float> points, Point result, int index1, int index2, float multiplier) {
+        float p1x = points.get(index1);
+        float p1y = points.get(index1 + 1);
+        float p2x = points.get(index2);
+        float p2y = points.get(index2 + 1);
+        float diffX = p2x - p1x;
+        float diffY = p2y - p1y;
+        result.setX(p1x + diffX * multiplier);
+        result.setY(p1y + diffY * multiplier);
+    }
+
+    protected void drawPoints(Canvas canvas, Paint paint, List<Float> pointsList, XYSeriesRenderer seriesRenderer, float yAxisValue, int seriesIndex, int startIndex) {
+        if (this.isRenderPoints(seriesRenderer)) {
+            ScatterChart pointsChart = this.getPointsChart();
+            if (pointsChart != null) {
+                int length = (int) this.mPathMeasure.getLength();
+                int pointsLength = pointsList.size();
+                float[] coords = new float[2];
+
+                for (int i = 0; i < length; ++i) {
+                    this.mPathMeasure.getPosTan((float) i, coords, null);
+                    double prevDiff = 1.7976931348623157E308D;
+                    boolean ok = true;
+
+                    for (int j = 0; j < pointsLength && ok; j += 2) {
+                        double diff = (double) Math.abs(pointsList.get(j) - coords[0]);
+                        if (diff < 1.0D) {
+                            pointsList.set(j + 1, coords[1]);
+                            prevDiff = diff;
+                        }
+
+                        ok = prevDiff > diff;
+                    }
+                }
+
+                pointsChart.drawSeries(canvas, paint, pointsList, seriesRenderer, yAxisValue, seriesIndex, startIndex);
+            }
+        }
+
+    }
+
+    public String getChartType() {
+        return "Cubic";
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/TimeChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/TimeChart.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/TimeChart.java	(date 1580376425000)
@@ -0,0 +1,174 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+
+public class TimeChart extends LineChart {
+    public static final String TYPE = "Time";
+    public static final long DAY = 86400000L;
+    private String mDateFormat;
+    private Double mStartPoint;
+
+    TimeChart() {
+    }
+
+    public TimeChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        super(dataset, renderer);
+    }
+
+    public String getDateFormat() {
+        return this.mDateFormat;
+    }
+
+    public void setDateFormat(String format) {
+        this.mDateFormat = format;
+    }
+
+    protected void drawXLabels(List<Double> xLabels, Double[] xTextLabelLocations, Canvas canvas, Paint paint, int left, int top, int bottom, double xPixelsPerUnit, double minX, double maxX) {
+        int length = xLabels.size();
+        if (length > 0) {
+            boolean showLabels = this.mRenderer.isShowLabels();
+            boolean showGridY = this.mRenderer.isShowGridY();
+            boolean showTickMarks = this.mRenderer.isShowTickMarks();
+            DateFormat format = this.getDateFormat((Double) xLabels.get(0), (Double) xLabels.get(length - 1));
+
+            for (int i = 0; i < length; ++i) {
+                long label = Math.round((Double) xLabels.get(i));
+                float xLabel = (float) ((double) left + xPixelsPerUnit * ((double) label - minX));
+                if (showLabels) {
+                    paint.setColor(this.mRenderer.getXLabelsColor());
+                    if (showTickMarks) {
+                        canvas.drawLine(xLabel, (float) bottom, xLabel, (float) bottom + this.mRenderer.getLabelsTextSize() / 3.0F, paint);
+                    }
+
+                    this.drawText(canvas, format.format(new Date(label)), xLabel, (float) bottom + this.mRenderer.getLabelsTextSize() * 4.0F / 3.0F + this.mRenderer.getXLabelsPadding(), paint, this.mRenderer.getXLabelsAngle());
+                }
+
+                if (showGridY) {
+                    paint.setColor(this.mRenderer.getGridColor(0));
+                    canvas.drawLine(xLabel, (float) bottom, xLabel, (float) top, paint);
+                }
+            }
+        }
+
+        this.drawXTextLabels(xTextLabelLocations, canvas, paint, true, left, top, bottom, xPixelsPerUnit, minX, maxX);
+    }
+
+    private DateFormat getDateFormat(double start, double end) {
+        DateFormat format;
+        if (this.mDateFormat != null) {
+
+            try {
+                format = new SimpleDateFormat(this.mDateFormat);
+                return format;
+            } catch (Exception var8) {
+            }
+        }
+
+        format = SimpleDateFormat.getDateInstance(2);
+        double diff = end - start;
+        if (diff > 8.64E7D && diff < 4.32E8D) {
+            format = SimpleDateFormat.getDateTimeInstance(3, 3);
+        } else if (diff < 8.64E7D) {
+            format = SimpleDateFormat.getTimeInstance(2);
+        }
+
+        return format;
+    }
+
+    public String getChartType() {
+        return "Time";
+    }
+
+    protected List<Double> getXLabels(double min, double max, int count) {
+        List<Double> result = new ArrayList();
+        int i;
+        if (!this.mRenderer.isXRoundedLabels()) {
+            if (this.mDataset.getSeriesCount() <= 0) {
+                return super.getXLabels(min, max, count);
+            } else {
+                XYSeries series = this.mDataset.getSeriesAt(0);
+                int length = series.getItemCount();
+                int intervalLength = 0;
+                int startIndex = -1;
+
+
+                for (i = 0; i < length; ++i) {
+                    double value = series.getX(i);
+                    if (min <= value && value <= max) {
+                        ++intervalLength;
+                        if (startIndex < 0) {
+                            startIndex = i;
+                        }
+                    }
+                }
+
+                if (intervalLength < count) {
+                    for (i = startIndex; i < startIndex + intervalLength; ++i) {
+                        result.add(series.getX(i));
+                    }
+                } else {
+                    float step = (float) intervalLength / (float) count;
+                    int intervalCount = 0;
+
+                    for (i = 0; i < length && intervalCount < count; ++i) {
+                        double value = series.getX(Math.round((float) i * step));
+                        if (min <= value && value <= max) {
+                            result.add(value);
+                            ++intervalCount;
+                        }
+                    }
+                }
+
+                return result;
+            }
+        } else {
+            if (this.mStartPoint == null) {
+                this.mStartPoint = min - min % 8.64E7D + 8.64E7D + (double) ((new Date(Math.round(min))).getTimezoneOffset() * 60 * 1000);
+            }
+
+            if (count > 25) {
+                count = 25;
+            }
+
+            double cycleMath = (max - min) / (double) count;
+            if (cycleMath <= 0.0D) {
+                return result;
+            } else {
+                double cycle = 8.64E7D;
+                if (cycleMath <= 8.64E7D) {
+                    while (cycleMath < cycle / 2.0D) {
+                        cycle /= 2.0D;
+                    }
+                } else {
+                    while (cycleMath > cycle) {
+                        cycle *= 2.0D;
+                    }
+                }
+
+                double val = this.mStartPoint - Math.floor((this.mStartPoint - min) / cycle) * cycle;
+
+                for (i = 0; val < max && i++ <= count; val += cycle) {
+                    result.add(val);
+                }
+
+                return result;
+            }
+        }
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/DoughnutChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/DoughnutChart.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/DoughnutChart.java	(date 1580376425000)
@@ -0,0 +1,117 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.RectF;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.CategorySeries;
+import www.jingkan.com.view.chart.achartengine.model.MultipleCategorySeries;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+
+public class DoughnutChart extends RoundChart {
+    private MultipleCategorySeries mDataset;
+    private int mStep;
+
+    public DoughnutChart(MultipleCategorySeries dataset, DefaultRenderer renderer) {
+        super((CategorySeries) null, renderer);
+        this.mDataset = dataset;
+    }
+
+    public void draw(Canvas canvas, int x, int y, int width, int height, Paint paint) {
+        paint.setAntiAlias(this.mRenderer.isAntialiasing());
+        paint.setStyle(Style.FILL);
+        paint.setTextSize(this.mRenderer.getLabelsTextSize());
+        int legendSize = this.getLegendSize(this.mRenderer, height / 5, 0.0F);
+        int left = x;
+        int right = x + width;
+        int cLength = this.mDataset.getCategoriesCount();
+        String[] categories = new String[cLength];
+
+        int bottom;
+        for (bottom = 0; bottom < cLength; ++bottom) {
+            categories[bottom] = this.mDataset.getCategory(bottom);
+        }
+
+        if (this.mRenderer.isFitLegend()) {
+            legendSize = this.drawLegend(canvas, this.mRenderer, categories, x, right, y, width, height, legendSize, paint, true);
+        }
+
+        bottom = y + height - legendSize;
+        this.drawBackground(this.mRenderer, canvas, x, y, width, height, paint, false, 0);
+        this.mStep = 7;
+        int mRadius = Math.min(Math.abs(right - x), Math.abs(bottom - y));
+        double rCoef = 0.35D * (double) this.mRenderer.getScale();
+        double decCoef = 0.2D / (double) cLength;
+        int radius = (int) ((double) mRadius * rCoef);
+        if (this.mCenterX == 2147483647) {
+            this.mCenterX = (x + right) / 2;
+        }
+
+        if (this.mCenterY == 2147483647) {
+            this.mCenterY = (bottom + y) / 2;
+        }
+
+        float shortRadius = (float) radius * 0.9F;
+        float longRadius = (float) radius * 1.1F;
+        List<RectF> prevLabelsBounds = new ArrayList();
+
+        for (int category = 0; category < cLength; ++category) {
+            int sLength = this.mDataset.getItemCount(category);
+            double total = 0.0D;
+            String[] titles = new String[sLength];
+
+            for (int i = 0; i < sLength; ++i) {
+                total += this.mDataset.getValues(category)[i];
+                titles[i] = this.mDataset.getTitles(category)[i];
+            }
+
+            float currentAngle = this.mRenderer.getStartAngle();
+            RectF oval = new RectF((float) (this.mCenterX - radius), (float) (this.mCenterY - radius), (float) (this.mCenterX + radius), (float) (this.mCenterY + radius));
+
+            for (int i = 0; i < sLength; ++i) {
+                paint.setColor(this.mRenderer.getSeriesRendererAt(i).getColor());
+                float value = (float) this.mDataset.getValues(category)[i];
+                float angle = (float) ((double) value / total * 360.0D);
+                canvas.drawArc(oval, currentAngle, angle, true, paint);
+                this.drawLabel(canvas, this.mDataset.getTitles(category)[i], this.mRenderer, prevLabelsBounds, this.mCenterX, this.mCenterY, shortRadius, longRadius, currentAngle, angle, left, right, this.mRenderer.getLabelsColor(), paint, true, false);
+                currentAngle += angle;
+            }
+
+            radius = (int) ((double) radius - (double) mRadius * decCoef);
+            shortRadius = (float) ((double) shortRadius - ((double) mRadius * decCoef - 2.0D));
+            if (this.mRenderer.getBackgroundColor() != 0) {
+                paint.setColor(this.mRenderer.getBackgroundColor());
+            } else {
+                paint.setColor(-1);
+            }
+
+            paint.setStyle(Style.FILL);
+            oval = new RectF((float) (this.mCenterX - radius), (float) (this.mCenterY - radius), (float) (this.mCenterX + radius), (float) (this.mCenterY + radius));
+            canvas.drawArc(oval, 0.0F, 360.0F, true, paint);
+            --radius;
+        }
+
+        prevLabelsBounds.clear();
+        this.drawLegend(canvas, this.mRenderer, categories, left, right, y, width, height, legendSize, paint, false);
+        this.drawTitle(canvas, x, y, width, paint);
+    }
+
+    public int getLegendShapeWidth(int seriesIndex) {
+        return 10;
+    }
+
+    public void drawLegendShape(Canvas canvas, SimpleSeriesRenderer renderer, float x, float y, int seriesIndex, Paint paint) {
+        --this.mStep;
+        canvas.drawCircle(x + 10.0F - (float) this.mStep, y, (float) this.mStep, paint);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/DialChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/DialChart.java	(date 1580376426000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/DialChart.java	(date 1580376426000)
@@ -0,0 +1,165 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Paint.Style;
+
+import www.jingkan.com.view.chart.achartengine.model.CategorySeries;
+import www.jingkan.com.view.chart.achartengine.renderer.DialRenderer;
+
+
+public class DialChart extends RoundChart {
+    private static final int NEEDLE_RADIUS = 10;
+    private DialRenderer mRenderer;
+
+    public DialChart(CategorySeries dataset, DialRenderer renderer) {
+        super(dataset, renderer);
+        this.mRenderer = renderer;
+    }
+
+    public void draw(Canvas canvas, int x, int y, int width, int height, Paint paint) {
+        paint.setAntiAlias(this.mRenderer.isAntialiasing());
+        paint.setStyle(Style.FILL);
+        paint.setTextSize(this.mRenderer.getLabelsTextSize());
+        int legendSize = this.getLegendSize(this.mRenderer, height / 5, 0.0F);
+        int right = x + width;
+        int sLength = this.mDataset.getItemCount();
+        String[] titles = new String[sLength];
+
+        int bottom;
+        for (bottom = 0; bottom < sLength; ++bottom) {
+            titles[bottom] = this.mDataset.getCategory(bottom);
+        }
+
+        if (this.mRenderer.isFitLegend()) {
+            legendSize = this.drawLegend(canvas, this.mRenderer, titles, x, right, y, width, height, legendSize, paint, true);
+        }
+
+        bottom = y + height - legendSize;
+        this.drawBackground(this.mRenderer, canvas, x, y, width, height, paint, false, 0);
+        int mRadius = Math.min(Math.abs(right - x), Math.abs(bottom - y));
+        int radius = (int) ((double) mRadius * 0.35D * (double) this.mRenderer.getScale());
+        if (this.mCenterX == 2147483647) {
+            this.mCenterX = (x + right) / 2;
+        }
+
+        if (this.mCenterY == 2147483647) {
+            this.mCenterY = (bottom + y) / 2;
+        }
+
+        float shortRadius = (float) radius * 0.9F;
+        float longRadius = (float) radius * 1.1F;
+        double min = this.mRenderer.getMinValue();
+        double max = this.mRenderer.getMaxValue();
+        double angleMin = this.mRenderer.getAngleMin();
+        double angleMax = this.mRenderer.getAngleMax();
+        double value;
+        if (!this.mRenderer.isMinValueSet() || !this.mRenderer.isMaxValueSet()) {
+            int count = this.mRenderer.getSeriesRendererCount();
+
+            for (int i = 0; i < count; ++i) {
+                value = this.mDataset.getValue(i);
+                if (!this.mRenderer.isMinValueSet()) {
+                    min = Math.min(min, value);
+                }
+
+                if (!this.mRenderer.isMaxValueSet()) {
+                    max = Math.max(max, value);
+                }
+            }
+        }
+
+        if (min == max) {
+            min *= 0.5D;
+            max *= 1.5D;
+        }
+
+        paint.setColor(this.mRenderer.getLabelsColor());
+        double minorTicks = this.mRenderer.getMinorTicksSpacing();
+        value = this.mRenderer.getMajorTicksSpacing();
+        if (minorTicks == 1.7976931348623157E308D) {
+            minorTicks = (max - min) / 30.0D;
+        }
+
+        if (value == 1.7976931348623157E308D) {
+            value = (max - min) / 10.0D;
+        }
+
+        this.drawTicks(canvas, min, max, angleMin, angleMax, this.mCenterX, this.mCenterY, (double) longRadius, (double) radius, minorTicks, paint, false);
+        this.drawTicks(canvas, min, max, angleMin, angleMax, this.mCenterX, this.mCenterY, (double) longRadius, (double) shortRadius, value, paint, true);
+        int count = this.mRenderer.getSeriesRendererCount();
+
+        for (int i = 0; i < count; ++i) {
+            double angle = this.getAngleForValue(this.mDataset.getValue(i), angleMin, angleMax, min, max);
+            paint.setColor(this.mRenderer.getSeriesRendererAt(i).getColor());
+            boolean type = this.mRenderer.getVisualTypeForIndex(i) == DialRenderer.Type.ARROW;
+            this.drawNeedle(canvas, angle, this.mCenterX, this.mCenterY, (double) shortRadius, type, paint);
+        }
+
+        this.drawLegend(canvas, this.mRenderer, titles, x, right, y, width, height, legendSize, paint, false);
+        this.drawTitle(canvas, x, y, width, paint);
+    }
+
+    private double getAngleForValue(double value, double minAngle, double maxAngle, double min, double max) {
+        double angleDiff = maxAngle - minAngle;
+        double diff = max - min;
+        return Math.toRadians(minAngle + (value - min) * angleDiff / diff);
+    }
+
+    private void drawTicks(Canvas canvas, double min, double max, double minAngle, double maxAngle, int centerX, int centerY, double longRadius, double shortRadius, double ticks, Paint paint, boolean labels) {
+        for (double i = min; i <= max; i += ticks) {
+            double angle = this.getAngleForValue(i, minAngle, maxAngle, min, max);
+            double sinValue = Math.sin(angle);
+            double cosValue = Math.cos(angle);
+            int x1 = Math.round((float) centerX + (float) (shortRadius * sinValue));
+            int y1 = Math.round((float) centerY + (float) (shortRadius * cosValue));
+            int x2 = Math.round((float) centerX + (float) (longRadius * sinValue));
+            int y2 = Math.round((float) centerY + (float) (longRadius * cosValue));
+            canvas.drawLine((float) x1, (float) y1, (float) x2, (float) y2, paint);
+            if (labels) {
+                paint.setTextAlign(Align.LEFT);
+                if (x1 <= x2) {
+                    paint.setTextAlign(Align.RIGHT);
+                }
+
+                String text = i + "";
+                if (Math.round(i) == (long) i) {
+                    text = (long) i + "";
+                }
+
+                canvas.drawText(text, (float) x1, (float) y1, paint);
+            }
+        }
+
+    }
+
+    private void drawNeedle(Canvas canvas, double angle, int centerX, int centerY, double radius, boolean arrow, Paint paint) {
+        double diff = Math.toRadians(90.0D);
+        int needleSinValue = (int) (10.0D * Math.sin(angle - diff));
+        int needleCosValue = (int) (10.0D * Math.cos(angle - diff));
+        int needleX = (int) (radius * Math.sin(angle));
+        int needleY = (int) (radius * Math.cos(angle));
+        int needleCenterX = centerX + needleX;
+        int needleCenterY = centerY + needleY;
+        float[] points;
+        if (arrow) {
+            int arrowBaseX = centerX + (int) (radius * 0.85D * Math.sin(angle));
+            int arrowBaseY = centerY + (int) (radius * 0.85D * Math.cos(angle));
+            points = new float[]{(float) (arrowBaseX - needleSinValue), (float) (arrowBaseY - needleCosValue), (float) needleCenterX, (float) needleCenterY, (float) (arrowBaseX + needleSinValue), (float) (arrowBaseY + needleCosValue)};
+            float width = paint.getStrokeWidth();
+            paint.setStrokeWidth(5.0F);
+            canvas.drawLine((float) centerX, (float) centerY, (float) needleCenterX, (float) needleCenterY, paint);
+            paint.setStrokeWidth(width);
+        } else {
+            points = new float[]{(float) (centerX - needleSinValue), (float) (centerY - needleCosValue), (float) needleCenterX, (float) needleCenterY, (float) (centerX + needleSinValue), (float) (centerY + needleCosValue)};
+        }
+
+        this.drawPath(canvas, points, paint, true);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RangeBarChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RangeBarChart.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RangeBarChart.java	(date 1580376425000)
@@ -0,0 +1,90 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
+public class RangeBarChart extends BarChart {
+    public static final String TYPE = "RangeBar";
+
+    RangeBarChart() {
+    }
+
+    RangeBarChart(Type type) {
+        super(type);
+    }
+
+    public RangeBarChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer, Type type) {
+        super(dataset, renderer, type);
+    }
+
+    public void drawSeries(Canvas canvas, Paint paint, List<Float> points, XYSeriesRenderer seriesRenderer, float yAxisValue, int seriesIndex, int startIndex) {
+        int seriesNr = this.mDataset.getSeriesCount();
+        int length = points.size();
+        paint.setColor(seriesRenderer.getColor());
+        paint.setStyle(Style.FILL);
+        float halfDiffX = this.getHalfDiffX(points, length, seriesNr);
+        int start = 0;
+        if (startIndex > 0) {
+            start = 2;
+        }
+
+        for (int i = start; i < length; i += 4) {
+            if (points.size() > i + 3) {
+                float xMin = (Float) points.get(i);
+                float yMin = (Float) points.get(i + 1);
+                float xMax = (Float) points.get(i + 2);
+                float yMax = (Float) points.get(i + 3);
+                this.drawBar(canvas, xMin, yMin, xMax, yMax, halfDiffX, seriesNr, seriesIndex, paint);
+            }
+        }
+
+        paint.setColor(seriesRenderer.getColor());
+    }
+
+    protected void drawChartValuesText(Canvas canvas, XYSeries series, XYSeriesRenderer renderer, Paint paint, List<Float> points, int seriesIndex, int startIndex) {
+        int seriesNr = this.mDataset.getSeriesCount();
+        float halfDiffX = this.getHalfDiffX(points, points.size(), seriesNr);
+        int start = 0;
+        if (startIndex > 0) {
+            start = 2;
+        }
+
+        for (int i = start; i < points.size(); i += 4) {
+            int index = startIndex + i / 2;
+            float x = (Float) points.get(i);
+            if (this.mType == Type.DEFAULT) {
+                x += (float) (seriesIndex * 2) * halfDiffX - ((float) seriesNr - 1.5F) * halfDiffX;
+            }
+
+            if (!this.isNullValue(series.getY(index + 1)) && points.size() > i + 3) {
+                this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), series.getY(index + 1)), x, (Float) points.get(i + 3) - renderer.getChartValuesSpacing(), paint, 0.0F);
+            }
+
+            if (!this.isNullValue(series.getY(index)) && points.size() > i + 1) {
+                this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), series.getY(index)), x, (Float) points.get(i + 1) + renderer.getChartValuesTextSize() + renderer.getChartValuesSpacing() - 3.0F, paint, 0.0F);
+            }
+        }
+
+    }
+
+    protected float getCoeficient() {
+        return 0.5F;
+    }
+
+    public String getChartType() {
+        return "RangeBar";
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RangeStackedBarChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RangeStackedBarChart.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/RangeStackedBarChart.java	(date 1580376425000)
@@ -0,0 +1,20 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import org.achartengine.chart.BarChart.Type;
+
+public class RangeStackedBarChart extends RangeBarChart {
+    public static final String TYPE = "RangeStackedBar";
+
+    RangeStackedBarChart() {
+        super(Type.STACKED);
+    }
+
+    public String getChartType() {
+        return "RangeStackedBar";
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/model/MultipleCategorySeries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/model/MultipleCategorySeries.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/model/MultipleCategorySeries.java	(date 1580376425000)
@@ -0,0 +1,68 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.model;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+public class MultipleCategorySeries implements Serializable {
+    private String mTitle;
+    private List<String> mCategories = new ArrayList();
+    private List<String[]> mTitles = new ArrayList();
+    private List<double[]> mValues = new ArrayList();
+
+    public MultipleCategorySeries(String title) {
+        this.mTitle = title;
+    }
+
+    public void add(String[] titles, double[] values) {
+        this.add(this.mCategories.size() + "", titles, values);
+    }
+
+    public void add(String category, String[] titles, double[] values) {
+        this.mCategories.add(category);
+        this.mTitles.add(titles);
+        this.mValues.add(values);
+    }
+
+    public void remove(int index) {
+        this.mCategories.remove(index);
+        this.mTitles.remove(index);
+        this.mValues.remove(index);
+    }
+
+    public void clear() {
+        this.mCategories.clear();
+        this.mTitles.clear();
+        this.mValues.clear();
+    }
+
+    public double[] getValues(int index) {
+        return (double[]) this.mValues.get(index);
+    }
+
+    public String getCategory(int index) {
+        return (String) this.mCategories.get(index);
+    }
+
+    public int getCategoriesCount() {
+        return this.mCategories.size();
+    }
+
+    public int getItemCount(int index) {
+        return ((double[]) this.mValues.get(index)).length;
+    }
+
+    public String[] getTitles(int index) {
+        return (String[]) this.mTitles.get(index);
+    }
+
+    public XYSeries toXYSeries() {
+        XYSeries xySeries = new XYSeries(this.mTitle);
+        return xySeries;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/DialRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/DialRenderer.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/renderer/DialRenderer.java	(date 1580376425000)
@@ -0,0 +1,96 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.renderer;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class DialRenderer extends DefaultRenderer {
+    private double mAngleMin = 330.0D;
+    private double mAngleMax = 30.0D;
+    private double mMinValue = 1.7976931348623157E308D;
+    private double mMaxValue = -1.7976931348623157E308D;
+    private double mMinorTickSpacing = 1.7976931348623157E308D;
+    private double mMajorTickSpacing = 1.7976931348623157E308D;
+    private List<DialRenderer.Type> mVisualTypes = new ArrayList();
+
+    public DialRenderer() {
+    }
+
+    public double getAngleMin() {
+        return this.mAngleMin;
+    }
+
+    public void setAngleMin(double min) {
+        this.mAngleMin = min;
+    }
+
+    public double getAngleMax() {
+        return this.mAngleMax;
+    }
+
+    public void setAngleMax(double max) {
+        this.mAngleMax = max;
+    }
+
+    public double getMinValue() {
+        return this.mMinValue;
+    }
+
+    public void setMinValue(double min) {
+        this.mMinValue = min;
+    }
+
+    public boolean isMinValueSet() {
+        return this.mMinValue != 1.7976931348623157E308D;
+    }
+
+    public double getMaxValue() {
+        return this.mMaxValue;
+    }
+
+    public void setMaxValue(double max) {
+        this.mMaxValue = max;
+    }
+
+    public boolean isMaxValueSet() {
+        return this.mMaxValue != -1.7976931348623157E308D;
+    }
+
+    public double getMinorTicksSpacing() {
+        return this.mMinorTickSpacing;
+    }
+
+    public void setMinorTicksSpacing(double spacing) {
+        this.mMinorTickSpacing = spacing;
+    }
+
+    public double getMajorTicksSpacing() {
+        return this.mMajorTickSpacing;
+    }
+
+    public void setMajorTicksSpacing(double spacing) {
+        this.mMajorTickSpacing = spacing;
+    }
+
+    public DialRenderer.Type getVisualTypeForIndex(int index) {
+        return index < this.mVisualTypes.size() ? (DialRenderer.Type) this.mVisualTypes.get(index) : DialRenderer.Type.NEEDLE;
+    }
+
+    public void setVisualTypes(DialRenderer.Type[] types) {
+        this.mVisualTypes.clear();
+        this.mVisualTypes.addAll(Arrays.asList(types));
+    }
+
+    public static enum Type {
+        NEEDLE,
+        ARROW;
+
+        private Type() {
+        }
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieMapper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieMapper.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieMapper.java	(date 1580376425000)
@@ -0,0 +1,79 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.Point;
+import www.jingkan.com.view.chart.achartengine.model.SeriesSelection;
+
+public class PieMapper implements Serializable {
+    private List<PieSegment> mPieSegmentList = new ArrayList();
+    private int mPieChartRadius;
+    private int mCenterX;
+    private int mCenterY;
+
+    public PieMapper() {
+    }
+
+    public void setDimensions(int pieRadius, int centerX, int centerY) {
+        this.mPieChartRadius = pieRadius;
+        this.mCenterX = centerX;
+        this.mCenterY = centerY;
+    }
+
+    public boolean areAllSegmentPresent(int datasetSize) {
+        return this.mPieSegmentList.size() == datasetSize;
+    }
+
+    public void addPieSegment(int dataIndex, float value, float startAngle, float angle) {
+        this.mPieSegmentList.add(new PieSegment(dataIndex, value, startAngle, angle));
+    }
+
+    public void clearPieSegments() {
+        this.mPieSegmentList.clear();
+    }
+
+    public double getAngle(Point screenPoint) {
+        double dx = (double) (screenPoint.getX() - (float) this.mCenterX);
+        double dy = (double) (-(screenPoint.getY() - (float) this.mCenterY));
+        double inRads = Math.atan2(dy, dx);
+        if (inRads < 0.0D) {
+            inRads = Math.abs(inRads);
+        } else {
+            inRads = 6.283185307179586D - inRads;
+        }
+
+        return Math.toDegrees(inRads);
+    }
+
+    public boolean isOnPieChart(Point screenPoint) {
+        double sqValue = Math.pow((double) ((float) this.mCenterX - screenPoint.getX()), 2.0D) + Math.pow((double) ((float) this.mCenterY - screenPoint.getY()), 2.0D);
+        double radiusSquared = (double) (this.mPieChartRadius * this.mPieChartRadius);
+        boolean isOnPieChart = sqValue <= radiusSquared;
+        return isOnPieChart;
+    }
+
+    public SeriesSelection getSeriesAndPointForScreenCoordinate(Point screenPoint) {
+        if (this.isOnPieChart(screenPoint)) {
+            double angleFromPieCenter = this.getAngle(screenPoint);
+            Iterator i$ = this.mPieSegmentList.iterator();
+
+            while (i$.hasNext()) {
+                PieSegment pieSeg = (PieSegment) i$.next();
+                if (pieSeg.isInSegment(angleFromPieCenter)) {
+                    return new SeriesSelection(0, pieSeg.getDataIndex(), (double) pieSeg.getValue(), (double) pieSeg.getValue());
+                }
+            }
+        }
+
+        return null;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieChart.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieChart.java	(date 1580376425000)
@@ -0,0 +1,122 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.RadialGradient;
+import android.graphics.RectF;
+import android.graphics.Shader;
+import android.graphics.Shader.TileMode;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.CategorySeries;
+import www.jingkan.com.view.chart.achartengine.model.Point;
+import www.jingkan.com.view.chart.achartengine.model.SeriesSelection;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+
+public class PieChart extends RoundChart {
+    private PieMapper mPieMapper = new PieMapper();
+
+    public PieChart(CategorySeries dataset, DefaultRenderer renderer) {
+        super(dataset, renderer);
+    }
+
+    public void draw(Canvas canvas, int x, int y, int width, int height, Paint paint) {
+        paint.setAntiAlias(this.mRenderer.isAntialiasing());
+        paint.setStyle(Style.FILL);
+        paint.setTextSize(this.mRenderer.getLabelsTextSize());
+        int legendSize = this.getLegendSize(this.mRenderer, height / 5, 0.0F);
+        int left = x;
+        int right = x + width;
+        int sLength = this.mDataset.getItemCount();
+        double total = 0.0D;
+        String[] titles = new String[sLength];
+
+        int bottom;
+        for (bottom = 0; bottom < sLength; ++bottom) {
+            total += this.mDataset.getValue(bottom);
+            titles[bottom] = this.mDataset.getCategory(bottom);
+        }
+
+        if (this.mRenderer.isFitLegend()) {
+            legendSize = this.drawLegend(canvas, this.mRenderer, titles, x, right, y, width, height, legendSize, paint, true);
+        }
+
+        bottom = y + height - legendSize;
+        this.drawBackground(this.mRenderer, canvas, x, y, width, height, paint, false, 0);
+        float currentAngle = this.mRenderer.getStartAngle();
+        int mRadius = Math.min(Math.abs(right - x), Math.abs(bottom - y));
+        int radius = (int) ((double) mRadius * 0.35D * (double) this.mRenderer.getScale());
+        if (this.mCenterX == 2147483647) {
+            this.mCenterX = (x + right) / 2;
+        }
+
+        if (this.mCenterY == 2147483647) {
+            this.mCenterY = (bottom + y) / 2;
+        }
+
+        this.mPieMapper.setDimensions(radius, this.mCenterX, this.mCenterY);
+        boolean loadPieCfg = !this.mPieMapper.areAllSegmentPresent(sLength);
+        if (loadPieCfg) {
+            this.mPieMapper.clearPieSegments();
+        }
+
+        float shortRadius = (float) radius * 0.9F;
+        float longRadius = (float) radius * 1.1F;
+        RectF oval = new RectF((float) (this.mCenterX - radius), (float) (this.mCenterY - radius), (float) (this.mCenterX + radius), (float) (this.mCenterY + radius));
+        List<RectF> prevLabelsBounds = new ArrayList();
+
+        for (int i = 0; i < sLength; ++i) {
+            SimpleSeriesRenderer seriesRenderer = this.mRenderer.getSeriesRendererAt(i);
+            if (seriesRenderer.isGradientEnabled()) {
+                RadialGradient grad = new RadialGradient((float) this.mCenterX, (float) this.mCenterY, longRadius, seriesRenderer.getGradientStartColor(), seriesRenderer.getGradientStopColor(), TileMode.MIRROR);
+                paint.setShader(grad);
+            } else {
+                paint.setColor(seriesRenderer.getColor());
+            }
+
+            float value = (float) this.mDataset.getValue(i);
+            float angle = (float) ((double) value / total * 360.0D);
+            if (seriesRenderer.isHighlighted()) {
+                double rAngle = Math.toRadians((double) (90.0F - (currentAngle + angle / 2.0F)));
+                float translateX = (float) ((double) radius * 0.1D * Math.sin(rAngle));
+                float translateY = (float) ((double) radius * 0.1D * Math.cos(rAngle));
+                oval.offset(translateX, translateY);
+                canvas.drawArc(oval, currentAngle, angle, true, paint);
+                oval.offset(-translateX, -translateY);
+            } else {
+                canvas.drawArc(oval, currentAngle, angle, true, paint);
+            }
+
+            paint.setColor(seriesRenderer.getColor());
+            paint.setShader((Shader) null);
+            this.drawLabel(canvas, this.mDataset.getCategory(i), this.mRenderer, prevLabelsBounds, this.mCenterX, this.mCenterY, shortRadius, longRadius, currentAngle, angle, left, right, this.mRenderer.getLabelsColor(), paint, true, false);
+            if (this.mRenderer.isDisplayValues()) {
+                this.drawLabel(canvas, this.getLabel(this.mRenderer.getSeriesRendererAt(i).getChartValuesFormat(), this.mDataset.getValue(i)), this.mRenderer, prevLabelsBounds, this.mCenterX, this.mCenterY, shortRadius / 2.0F, longRadius / 2.0F, currentAngle, angle, left, right, this.mRenderer.getLabelsColor(), paint, false, true);
+            }
+
+            if (loadPieCfg) {
+                this.mPieMapper.addPieSegment(i, value, currentAngle, angle);
+            }
+
+            currentAngle += angle;
+        }
+
+        prevLabelsBounds.clear();
+        this.drawLegend(canvas, this.mRenderer, titles, left, right, y, width, height, legendSize, paint, false);
+        this.drawTitle(canvas, x, y, width, paint);
+    }
+
+    public SeriesSelection getSeriesAndPointForScreenCoordinate(Point screenPoint) {
+        return this.mPieMapper.getSeriesAndPointForScreenCoordinate(screenPoint);
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieSegment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieSegment.java	(date 1580376425000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PieSegment.java	(date 1580376425000)
@@ -0,0 +1,58 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import java.io.Serializable;
+
+public class PieSegment implements Serializable {
+    private float mStartAngle;
+    private float mEndAngle;
+    private int mDataIndex;
+    private float mValue;
+
+    public PieSegment(int dataIndex, float value, float startAngle, float angle) {
+        this.mStartAngle = startAngle;
+        this.mEndAngle = angle + startAngle;
+        this.mDataIndex = dataIndex;
+        this.mValue = value;
+    }
+
+    public boolean isInSegment(double angle) {
+        if (angle >= (double) this.mStartAngle && angle <= (double) this.mEndAngle) {
+            return true;
+        } else {
+            double cAngle = angle % 360.0D;
+            double startAngle = (double) this.mStartAngle;
+
+            double stopAngle;
+            for (stopAngle = (double) this.mEndAngle; stopAngle > 360.0D; stopAngle -= 360.0D) {
+                startAngle -= 360.0D;
+            }
+
+            return cAngle >= startAngle && cAngle <= stopAngle;
+        }
+    }
+
+    protected float getStartAngle() {
+        return this.mStartAngle;
+    }
+
+    protected float getEndAngle() {
+        return this.mEndAngle;
+    }
+
+    protected int getDataIndex() {
+        return this.mDataIndex;
+    }
+
+    protected float getValue() {
+        return this.mValue;
+    }
+
+    public String toString() {
+        return "mDataIndex=" + this.mDataIndex + ",mValue=" + this.mValue + ",mStartAngle=" + this.mStartAngle + ",mEndAngle=" + this.mEndAngle;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view_model/CalibrationVerificationVM.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view_model/CalibrationVerificationVM.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view_model/CalibrationVerificationVM.java	(date 1577158529000)
@@ -74,6 +74,7 @@
         String[] strings = (String[]) objects[0];
         isFs = strings[2].contains("侧壁");
         isCross = strings[2].contains("十字板");
+        isFa = strings[2].contains("斜度");
         mac = strings[0];
         initProbeParameters(strings[1], isFs);
         list = new ArrayList<>();
@@ -129,6 +130,7 @@
     private float initialValue = 0;
     private boolean isFs;
     private boolean isCross;
+    private boolean isFa;
     private List<String[]> list;
 
 
@@ -261,6 +263,29 @@
                         if (index == 31) {
                             for (int i = 0; i < list.size(); i++) {
                                 putDateBase(i, list.get(i));
+                            }
+                            toast("标定结束");
+                        }
+                    }
+                }
+            } else if (isFa) {
+                for (; index < 44; index++) {
+                    double v = 0.3 * ra.nextDouble() * (ra.nextBoolean() ? 1 : -1);
+                    if (index < 11) {
+                        x = index * differential;
+                        list.add(new String[]{String.valueOf(x), "加荷", StringUtil.format(x + v, 2)});
+                    } else if (index < 22) {
+                        x = (13 - index) * differential;
+                        list.add(new String[]{String.valueOf(x), "卸荷", StringUtil.format(x + v, 2)});
+                    } else if (index < 33) {
+                        x = (index - 14) * differential;
+                        list.add(new String[]{String.valueOf(x), "加荷", StringUtil.format(x + v, 2)});
+                    } else {
+                        x = (27 - index) * differential;
+                        list.add(new String[]{String.valueOf(x), "卸荷", StringUtil.format(x + v, 2)});
+                        if (index == 27) {
+                            for (int i = 0; i < list.size(); i++) {
+                                putDateBase(i, list.get(i));
                             }
                             toast("标定结束");
                         }
Index: app/src/main/res/layout/activity_choose_calibration_type.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_choose_calibration_type.xml	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/res/layout/activity_choose_calibration_type.xml	(date 1577155276000)
@@ -69,4 +69,33 @@
             android:background="@color/them_color" />
     </RelativeLayout>
 
+    <RelativeLayout
+        android:id="@+id/rl_fa"
+        android:layout_width="match_parent"
+        android:layout_height="48dp">
+
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:layout_marginLeft="8dp"
+            android:gravity="center"
+            android:text="斜度标定"
+            android:textColor="@color/tv_black"
+            android:textSize="18sp" />
+
+        <ImageView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_alignParentEnd="true"
+            android:layout_alignParentRight="true"
+            android:layout_centerVertical="true"
+            android:layout_marginRight="8dp"
+            android:src="@mipmap/next" />
+
+        <View
+            android:layout_width="match_parent"
+            android:layout_height="1dp"
+            android:layout_alignParentBottom="true"
+            android:background="@color/them_color" />
+    </RelativeLayout>
 </LinearLayout>
\ No newline at end of file
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/AbstractChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/AbstractChart.java	(date 1580289897000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/AbstractChart.java	(date 1580289897000)
@@ -0,0 +1,369 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Paint.Style;
+import android.graphics.Path;
+import android.graphics.Rect;
+import android.graphics.RectF;
+
+import java.io.Serializable;
+import java.text.NumberFormat;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.Point;
+import www.jingkan.com.view.chart.achartengine.model.SeriesSelection;
+import www.jingkan.com.view.chart.achartengine.renderer.DefaultRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+
+public abstract class AbstractChart implements Serializable {
+    public AbstractChart() {
+    }
+
+    public abstract void draw(Canvas var1, int var2, int var3, int var4, int var5, Paint var6);
+
+    protected void drawBackground(DefaultRenderer renderer, Canvas canvas, int x, int y, int width, int height, Paint paint, boolean newColor, int color) {
+        if (renderer.isApplyBackgroundColor() || newColor) {
+            if (newColor) {
+                paint.setColor(color);
+            } else {
+                paint.setColor(renderer.getBackgroundColor());
+            }
+
+            paint.setStyle(Style.FILL);
+            canvas.drawRect((float) x, (float) y, (float) (x + width), (float) (y + height), paint);
+        }
+
+    }
+
+    protected int drawLegend(Canvas canvas, DefaultRenderer renderer, String[] titles, int left, int right, int y, int width, int height, int legendSize, Paint paint, boolean calculate) {
+        float size = 32.0F;
+        if (renderer.isShowLegend()) {
+            float currentX = (float) left;
+            float currentY = (float) (y + height - legendSize) + size;
+            paint.setTextAlign(Align.LEFT);
+            paint.setTextSize(renderer.getLegendTextSize());
+            int sLength = Math.min(titles.length, renderer.getSeriesRendererCount());
+
+            for (int i = 0; i < sLength; ++i) {
+                SimpleSeriesRenderer r = renderer.getSeriesRendererAt(i);
+                float lineSize = (float) this.getLegendShapeWidth(i);
+                if (r.isShowLegendItem()) {
+                    String text = titles[i];
+                    if (titles.length == renderer.getSeriesRendererCount()) {
+                        paint.setColor(r.getColor());
+                    } else {
+                        paint.setColor(-3355444);
+                    }
+
+                    float[] widths = new float[text.length()];
+                    paint.getTextWidths(text, widths);
+                    float sum = 0.0F;
+                    float[] arr$ = widths;
+                    int len$ = widths.length;
+
+                    for (int i$ = 0; i$ < len$; ++i$) {
+                        float value = arr$[i$];
+                        sum += value;
+                    }
+
+                    float extraSize = lineSize + 10.0F + sum;
+                    float currentWidth = currentX + extraSize;
+                    if (i > 0 && this.getExceed(currentWidth, renderer, right, width)) {
+                        currentX = (float) left;
+                        currentY += renderer.getLegendTextSize();
+                        size += renderer.getLegendTextSize();
+                        currentWidth = currentX + extraSize;
+                    }
+
+                    if (this.getExceed(currentWidth, renderer, right, width)) {
+                        float maxWidth = (float) right - currentX - lineSize - 10.0F;
+                        if (this.isVertical(renderer)) {
+                            maxWidth = (float) width - currentX - lineSize - 10.0F;
+                        }
+
+                        int nr = paint.breakText(text, true, maxWidth, widths);
+                        text = text.substring(0, nr) + "...";
+                    }
+
+                    if (!calculate) {
+                        this.drawLegendShape(canvas, r, currentX, currentY, i, paint);
+                        this.drawString(canvas, text, currentX + lineSize + 5.0F, currentY + 5.0F, paint);
+                    }
+
+                    currentX += extraSize;
+                }
+            }
+        }
+
+        return Math.round(size + renderer.getLegendTextSize());
+    }
+
+    protected void drawString(Canvas canvas, String text, float x, float y, Paint paint) {
+        if (text != null) {
+            String[] lines = text.split("\n");
+            Rect rect = new Rect();
+            int yOff = 0;
+
+            for (int i = 0; i < lines.length; ++i) {
+                canvas.drawText(lines[i], x, y + (float) yOff, paint);
+                paint.getTextBounds(lines[i], 0, lines[i].length(), rect);
+                yOff = yOff + rect.height() + 5;
+            }
+        }
+
+    }
+
+    protected boolean getExceed(float currentWidth, DefaultRenderer renderer, int right, int width) {
+        boolean exceed = currentWidth > (float) right;
+        if (this.isVertical(renderer)) {
+            exceed = currentWidth > (float) width;
+        }
+
+        return exceed;
+    }
+
+    public boolean isVertical(DefaultRenderer renderer) {
+        return renderer instanceof XYMultipleSeriesRenderer && ((XYMultipleSeriesRenderer) renderer).getOrientation() == XYMultipleSeriesRenderer.Orientation.VERTICAL;
+    }
+
+    protected String getLabel(NumberFormat format, double label) {
+        String text = "";
+        if (format != null) {
+            text = format.format(label);
+        } else if (label == (double) Math.round(label)) {
+            text = Math.round(label) + "";
+        } else {
+            text = label + "";
+        }
+
+        return text;
+    }
+
+    private static float[] calculateDrawPoints(float p1x, float p1y, float p2x, float p2y, int screenHeight, int screenWidth) {
+        float drawP1x;
+        float drawP1y;
+        float m;
+        if (p1y > (float) screenHeight) {
+            m = (p2y - p1y) / (p2x - p1x);
+            drawP1x = ((float) screenHeight - p1y + m * p1x) / m;
+            drawP1y = (float) screenHeight;
+            if (drawP1x < 0.0F) {
+                drawP1x = 0.0F;
+                drawP1y = p1y - m * p1x;
+            } else if (drawP1x > (float) screenWidth) {
+                drawP1x = (float) screenWidth;
+                drawP1y = m * (float) screenWidth + p1y - m * p1x;
+            }
+        } else if (p1y < 0.0F) {
+            m = (p2y - p1y) / (p2x - p1x);
+            drawP1x = (-p1y + m * p1x) / m;
+            drawP1y = 0.0F;
+            if (drawP1x < 0.0F) {
+                drawP1x = 0.0F;
+                drawP1y = p1y - m * p1x;
+            } else if (drawP1x > (float) screenWidth) {
+                drawP1x = (float) screenWidth;
+                drawP1y = m * (float) screenWidth + p1y - m * p1x;
+            }
+        } else {
+            drawP1x = p1x;
+            drawP1y = p1y;
+        }
+
+        float drawP2x;
+        float drawP2y;
+        if (p2y > (float) screenHeight) {
+            m = (p2y - p1y) / (p2x - p1x);
+            drawP2x = ((float) screenHeight - p1y + m * p1x) / m;
+            drawP2y = (float) screenHeight;
+            if (drawP2x < 0.0F) {
+                drawP2x = 0.0F;
+                drawP2y = p1y - m * p1x;
+            } else if (drawP2x > (float) screenWidth) {
+                drawP2x = (float) screenWidth;
+                drawP2y = m * (float) screenWidth + p1y - m * p1x;
+            }
+        } else if (p2y < 0.0F) {
+            m = (p2y - p1y) / (p2x - p1x);
+            drawP2x = (-p1y + m * p1x) / m;
+            drawP2y = 0.0F;
+            if (drawP2x < 0.0F) {
+                drawP2x = 0.0F;
+                drawP2y = p1y - m * p1x;
+            } else if (drawP2x > (float) screenWidth) {
+                drawP2x = (float) screenWidth;
+                drawP2y = m * (float) screenWidth + p1y - m * p1x;
+            }
+        } else {
+            drawP2x = p2x;
+            drawP2y = p2y;
+        }
+
+        return new float[]{drawP1x, drawP1y, drawP2x, drawP2y};
+    }
+
+    protected void drawPath(Canvas canvas, List<Float> points, Paint paint, boolean circular) {
+        Path path = new Path();
+        int height = canvas.getHeight();
+        int width = canvas.getWidth();
+        if (points.size() >= 4) {
+            float[] tempDrawPoints = calculateDrawPoints((Float) points.get(0), (Float) points.get(1), (Float) points.get(2), (Float) points.get(3), height, width);
+            path.moveTo(tempDrawPoints[0], tempDrawPoints[1]);
+            path.lineTo(tempDrawPoints[2], tempDrawPoints[3]);
+            int length = points.size();
+
+            for (int i = 4; i < length; i += 2) {
+                if (((Float) points.get(i - 1) >= 0.0F || (Float) points.get(i + 1) >= 0.0F) && ((Float) points.get(i - 1) <= (float) height || (Float) points.get(i + 1) <= (float) height)) {
+                    tempDrawPoints = calculateDrawPoints((Float) points.get(i - 2), (Float) points.get(i - 1), (Float) points.get(i), (Float) points.get(i + 1), height, width);
+                    if (!circular) {
+                        path.moveTo(tempDrawPoints[0], tempDrawPoints[1]);
+                    }
+
+                    path.lineTo(tempDrawPoints[2], tempDrawPoints[3]);
+                }
+            }
+
+            if (circular) {
+                path.lineTo((Float) points.get(0), (Float) points.get(1));
+            }
+
+            canvas.drawPath(path, paint);
+        }
+    }
+
+    protected void drawPath(Canvas canvas, float[] points, Paint paint, boolean circular) {
+        Path path = new Path();
+        int height = canvas.getHeight();
+        int width = canvas.getWidth();
+        if (points.length >= 4) {
+            float[] tempDrawPoints = calculateDrawPoints(points[0], points[1], points[2], points[3], height, width);
+            path.moveTo(tempDrawPoints[0], tempDrawPoints[1]);
+            path.lineTo(tempDrawPoints[2], tempDrawPoints[3]);
+            int length = points.length;
+
+            for (int i = 4; i < length; i += 2) {
+                if ((points[i - 1] >= 0.0F || points[i + 1] >= 0.0F) && (points[i - 1] <= (float) height || points[i + 1] <= (float) height)) {
+                    tempDrawPoints = calculateDrawPoints(points[i - 2], points[i - 1], points[i], points[i + 1], height, width);
+                    if (!circular) {
+                        path.moveTo(tempDrawPoints[0], tempDrawPoints[1]);
+                    }
+
+                    path.lineTo(tempDrawPoints[2], tempDrawPoints[3]);
+                }
+            }
+
+            if (circular) {
+                path.lineTo(points[0], points[1]);
+            }
+
+            canvas.drawPath(path, paint);
+        }
+    }
+
+    public abstract int getLegendShapeWidth(int var1);
+
+    public abstract void drawLegendShape(Canvas var1, SimpleSeriesRenderer var2, float var3, float var4, int var5, Paint var6);
+
+    private String getFitText(String text, float width, Paint paint) {
+        String newText = text;
+        int length = text.length();
+
+        int diff;
+        for (diff = 0; paint.measureText(newText) > width && diff < length; newText = text.substring(0, length - diff) + "...") {
+            ++diff;
+        }
+
+        if (diff == length) {
+            newText = "...";
+        }
+
+        return newText;
+    }
+
+    protected int getLegendSize(DefaultRenderer renderer, int defaultHeight, float extraHeight) {
+        int legendSize = renderer.getLegendHeight();
+        if (renderer.isShowLegend() && legendSize == 0) {
+            legendSize = defaultHeight;
+        }
+
+        if (!renderer.isShowLegend() && renderer.isShowLabels()) {
+            legendSize = (int) (renderer.getLabelsTextSize() * 4.0F / 3.0F + extraHeight);
+        }
+
+        return legendSize;
+    }
+
+    protected void drawLabel(Canvas canvas, String labelText, DefaultRenderer renderer, List<RectF> prevLabelsBounds, int centerX, int centerY, float shortRadius, float longRadius, float currentAngle, float angle, int left, int right, int color, Paint paint, boolean line, boolean display) {
+        if (renderer.isShowLabels() || display) {
+            paint.setColor(color);
+            double rAngle = Math.toRadians((double) (90.0F - (currentAngle + angle / 2.0F)));
+            double sinValue = Math.sin(rAngle);
+            double cosValue = Math.cos(rAngle);
+            int x1 = Math.round((float) centerX + (float) ((double) shortRadius * sinValue));
+            int y1 = Math.round((float) centerY + (float) ((double) shortRadius * cosValue));
+            int x2 = Math.round((float) centerX + (float) ((double) longRadius * sinValue));
+            int y2 = Math.round((float) centerY + (float) ((double) longRadius * cosValue));
+            float size = renderer.getLabelsTextSize();
+            float extra = Math.max(size / 2.0F, 10.0F);
+            paint.setTextAlign(Align.LEFT);
+            if (x1 > x2) {
+                extra = -extra;
+                paint.setTextAlign(Align.RIGHT);
+            }
+
+            float xLabel = (float) x2 + extra;
+            float yLabel = (float) y2;
+            float width = (float) right - xLabel;
+            if (x1 > x2) {
+                width = xLabel - (float) left;
+            }
+
+            labelText = this.getFitText(labelText, width, paint);
+            float widthLabel = paint.measureText(labelText);
+
+            boolean intersects;
+            for (boolean okBounds = false; !okBounds && line; okBounds = !intersects) {
+                intersects = false;
+                int length = prevLabelsBounds.size();
+
+                for (int j = 0; j < length && !intersects; ++j) {
+                    RectF prevLabelBounds = (RectF) prevLabelsBounds.get(j);
+                    if (prevLabelBounds.intersects(xLabel, yLabel, xLabel + widthLabel, yLabel + size)) {
+                        intersects = true;
+                        yLabel = Math.max(yLabel, prevLabelBounds.bottom);
+                    }
+                }
+            }
+
+            if (line) {
+                y2 = (int) (yLabel - size / 2.0F);
+                canvas.drawLine((float) x1, (float) y1, (float) x2, (float) y2, paint);
+                canvas.drawLine((float) x2, (float) y2, (float) x2 + extra, (float) y2, paint);
+            } else {
+                paint.setTextAlign(Align.CENTER);
+            }
+
+            canvas.drawText(labelText, xLabel, yLabel, paint);
+            if (line) {
+                prevLabelsBounds.add(new RectF(xLabel, yLabel, xLabel + widthLabel, yLabel + size));
+            }
+        }
+
+    }
+
+    public boolean isNullValue(double value) {
+        return Double.isNaN(value) || Double.isInfinite(value) || value == 1.7976931348623157E308D;
+    }
+
+    public SeriesSelection getSeriesAndPointForScreenCoordinate(Point screenPoint) {
+        return null;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/XYChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/XYChart.java	(date 1580289897000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/XYChart.java	(date 1580289897000)
@@ -0,0 +1,783 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.DashPathEffect;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Paint.Cap;
+import android.graphics.Paint.Join;
+import android.graphics.Paint.Style;
+import android.graphics.PathEffect;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.Typeface;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Objects;
+import java.util.SortedMap;
+
+import www.jingkan.com.view.chart.achartengine.model.Point;
+import www.jingkan.com.view.chart.achartengine.model.SeriesSelection;
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.model.XYSeries;
+import www.jingkan.com.view.chart.achartengine.renderer.BasicStroke;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.util.MathHelper;
+
+
+public abstract class XYChart extends AbstractChart {
+    protected XYMultipleSeriesDataset mDataset;
+    protected XYMultipleSeriesRenderer mRenderer;
+    private float mScale;
+    private float mTranslate;
+    private Point mCenter;
+    private Rect mScreenR;
+    private final Map<Integer, double[]> mCalcRange = new HashMap();
+    private Map<Integer, List<ClickableArea>> clickableAreas = new HashMap();
+
+    protected XYChart() {
+    }
+
+    public XYChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        this.mDataset = dataset;
+        this.mRenderer = renderer;
+    }
+
+    protected void setDatasetRenderer(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        this.mDataset = dataset;
+        this.mRenderer = renderer;
+    }
+
+    public void draw(Canvas canvas, int x, int y, int width, int height, Paint paint) {
+        paint.setAntiAlias(this.mRenderer.isAntialiasing());
+        int legendSize = this.getLegendSize(this.mRenderer, height / 5, this.mRenderer.getAxisTitleTextSize());
+        int[] margins = this.mRenderer.getMargins();
+        int left = x + margins[1];
+        int top = y + margins[0];
+        int right = x + width - margins[3];
+        int sLength = this.mDataset.getSeriesCount();
+        String[] titles = new String[sLength];
+
+        int bottom;
+        for (bottom = 0; bottom < sLength; ++bottom) {
+            titles[bottom] = this.mDataset.getSeriesAt(bottom).getTitle();
+        }
+
+        if (this.mRenderer.isFitLegend() && this.mRenderer.isShowLegend()) {
+            legendSize = this.drawLegend(canvas, this.mRenderer, titles, left, right, y, width, height, legendSize, paint, true);
+        }
+
+        bottom = y + height - margins[2] - legendSize;
+        if (this.mScreenR == null) {
+            this.mScreenR = new Rect();
+        }
+
+        this.mScreenR.set(left, top, right, bottom);
+        this.drawBackground(this.mRenderer, canvas, x, y, width, height, paint, false, 0);
+        if (paint.getTypeface() == null || this.mRenderer.getTextTypeface() != null && paint.getTypeface().equals(this.mRenderer.getTextTypeface()) || !paint.getTypeface().toString().equals(this.mRenderer.getTextTypefaceName()) || paint.getTypeface().getStyle() != this.mRenderer.getTextTypefaceStyle()) {
+            if (this.mRenderer.getTextTypeface() != null) {
+                paint.setTypeface(this.mRenderer.getTextTypeface());
+            } else {
+                paint.setTypeface(Typeface.create(this.mRenderer.getTextTypefaceName(), this.mRenderer.getTextTypefaceStyle()));
+            }
+        }
+
+        XYMultipleSeriesRenderer.Orientation or = this.mRenderer.getOrientation();
+        if (or == XYMultipleSeriesRenderer.Orientation.VERTICAL) {
+            right -= legendSize;
+            bottom += legendSize - 20;
+        }
+
+        int angle = or.getAngle();
+        boolean rotate = angle == 90;
+        this.mScale = (float) height / (float) width;
+        this.mTranslate = (float) (Math.abs(width - height) / 2);
+        if (this.mScale < 1.0F) {
+            this.mTranslate *= -1.0F;
+        }
+
+        this.mCenter = new Point((float) ((x + width) / 2), (float) ((y + height) / 2));
+        if (rotate) {
+            this.transform(canvas, (float) angle, false);
+        }
+
+        int maxScaleNumber = -2147483647;
+
+        for (int i = 0; i < sLength; ++i) {
+            maxScaleNumber = Math.max(maxScaleNumber, this.mDataset.getSeriesAt(i).getScaleNumber());
+        }
+
+        ++maxScaleNumber;
+        if (maxScaleNumber >= 0) {
+            double[] minX = new double[maxScaleNumber];
+            double[] maxX = new double[maxScaleNumber];
+            double[] minY = new double[maxScaleNumber];
+            double[] maxY = new double[maxScaleNumber];
+            boolean[] isMinXSet = new boolean[maxScaleNumber];
+            boolean[] isMaxXSet = new boolean[maxScaleNumber];
+            boolean[] isMinYSet = new boolean[maxScaleNumber];
+            boolean[] isMaxYSet = new boolean[maxScaleNumber];
+
+            for (int i = 0; i < maxScaleNumber; ++i) {
+                minX[i] = this.mRenderer.getXAxisMin(i);
+                maxX[i] = this.mRenderer.getXAxisMax(i);
+                minY[i] = this.mRenderer.getYAxisMin(i);
+                maxY[i] = this.mRenderer.getYAxisMax(i);
+                isMinXSet[i] = this.mRenderer.isMinXSet(i);
+                isMaxXSet[i] = this.mRenderer.isMaxXSet(i);
+                isMinYSet[i] = this.mRenderer.isMinYSet(i);
+                isMaxYSet[i] = this.mRenderer.isMaxYSet(i);
+                if (this.mCalcRange.get(i) == null) {
+                    this.mCalcRange.put(i, new double[4]);
+                }
+            }
+
+            double[] xPixelsPerUnit = new double[maxScaleNumber];
+            double[] yPixelsPerUnit = new double[maxScaleNumber];
+
+            int i;
+            for (i = 0; i < sLength; ++i) {
+                XYSeries series = this.mDataset.getSeriesAt(i);
+                int scale = series.getScaleNumber();
+                if (series.getItemCount() != 0) {
+                    double maximumY;
+                    if (!isMinXSet[scale]) {
+                        maximumY = series.getMinX();
+                        minX[scale] = Math.min(minX[scale], maximumY);
+                        this.mCalcRange.get(scale)[0] = minX[scale];
+                    }
+
+                    if (!isMaxXSet[scale]) {
+                        maximumY = series.getMaxX();
+                        maxX[scale] = Math.max(maxX[scale], maximumY);
+                        Objects.requireNonNull(this.mCalcRange.get(scale))[1] = maxX[scale];
+                    }
+
+                    if (!isMinYSet[scale]) {
+                        maximumY = series.getMinY();
+                        minY[scale] = Math.min(minY[scale], (double) ((float) maximumY));
+                        this.mCalcRange.get(scale)[2] = minY[scale];
+                    }
+
+                    if (!isMaxYSet[scale]) {
+                        maximumY = series.getMaxY();
+                        maxY[scale] = Math.max(maxY[scale], (double) ((float) maximumY));
+                        Objects.requireNonNull(this.mCalcRange.get(scale))[3] = maxY[scale];
+                    }
+                }
+            }
+
+            for (i = 0; i < maxScaleNumber; ++i) {
+                if (maxX[i] - minX[i] != 0.0D) {
+                    xPixelsPerUnit[i] = (double) (right - left) / (maxX[i] - minX[i]);
+                }
+
+                if (maxY[i] - minY[i] != 0.0D) {
+                    yPixelsPerUnit[i] = (double) ((float) ((double) (bottom - top) / (maxY[i] - minY[i])));
+                }
+
+                if (i > 0) {
+                    xPixelsPerUnit[i] = xPixelsPerUnit[0];
+                    minX[i] = minX[0];
+                    maxX[i] = maxX[0];
+                }
+            }
+
+            boolean hasValues = false;
+            this.clickableAreas = new HashMap();
+
+            float yLabel;
+            int len$;
+            for (i = 0; i < sLength; ++i) {
+                XYSeries series = this.mDataset.getSeriesAt(i);
+                int scale = series.getScaleNumber();
+                if (series.getItemCount() != 0) {
+                    hasValues = true;
+                    XYSeriesRenderer seriesRenderer = (XYSeriesRenderer) this.mRenderer.getSeriesRendererAt(i);
+                    List<Float> points = new ArrayList();
+                    List<Double> values = new ArrayList();
+                    float yAxisValue = Math.min((float) bottom, (float) ((double) bottom + yPixelsPerUnit[scale] * minY[scale]));
+                    LinkedList<ClickableArea> clickableArea = new LinkedList();
+                    this.clickableAreas.put(i, clickableArea);
+                    synchronized (series) {
+                        SortedMap<Double, Double> range = series.getRange(minX[scale], maxX[scale], seriesRenderer.isDisplayBoundingPoints());
+                        int startIndex = -1;
+                        Iterator i$ = range.entrySet().iterator();
+
+                        while (i$.hasNext()) {
+                            Entry<Double, Double> value = (Entry) i$.next();
+                            double xValue = (Double) value.getKey();
+                            double yValue = (Double) value.getValue();
+                            if (startIndex < 0 && (!this.isNullValue(yValue) || this.isRenderNullValues())) {
+                                startIndex = series.getIndexForKey(xValue);
+                            }
+
+                            values.add(value.getKey());
+                            values.add(value.getValue());
+                            if (!this.isNullValue(yValue)) {
+                                points.add((float) ((double) left + xPixelsPerUnit[scale] * (xValue - minX[scale])));
+                                points.add((float) ((double) bottom - yPixelsPerUnit[scale] * (yValue - minY[scale])));
+                            } else if (this.isRenderNullValues()) {
+                                points.add((float) ((double) left + xPixelsPerUnit[scale] * (xValue - minX[scale])));
+                                points.add((float) ((double) bottom - yPixelsPerUnit[scale] * -minY[scale]));
+                            } else {
+                                if (points.size() > 0) {
+                                    this.drawSeries(series, canvas, paint, points, seriesRenderer, yAxisValue, i, or, startIndex);
+                                    ClickableArea[] clickableAreasForSubSeries = this.clickableAreasForPoints(points, values, yAxisValue, i, startIndex);
+                                    clickableArea.addAll(Arrays.asList(clickableAreasForSubSeries));
+                                    points.clear();
+                                    values.clear();
+                                    startIndex = -1;
+                                }
+
+                                clickableArea.add(null);
+                            }
+                        }
+
+                        len$ = series.getAnnotationCount();
+                        if (len$ > 0) {
+                            paint.setColor(seriesRenderer.getAnnotationsColor());
+                            paint.setTextSize(seriesRenderer.getAnnotationsTextSize());
+                            paint.setTextAlign(seriesRenderer.getAnnotationsTextAlign());
+                            Rect bound = new Rect();
+
+                            for (int j = 0; j < len$; ++j) {
+                                yLabel = (float) ((double) left + xPixelsPerUnit[scale] * (series.getAnnotationX(j) - minX[scale]));
+                                float yS = (float) ((double) bottom - yPixelsPerUnit[scale] * (series.getAnnotationY(j) - minY[scale]));
+                                paint.getTextBounds(series.getAnnotationAt(j), 0, series.getAnnotationAt(j).length(), bound);
+                                if (yLabel < yLabel + (float) bound.width() && yS < (float) canvas.getHeight()) {
+                                    this.drawString(canvas, series.getAnnotationAt(j), yLabel, yS, paint);
+                                }
+                            }
+                        }
+
+                        if (points.size() > 0) {
+                            this.drawSeries(series, canvas, paint, points, seriesRenderer, yAxisValue, i, or, startIndex);
+                            ClickableArea[] clickableAreasForSubSeries = this.clickableAreasForPoints(points, values, yAxisValue, i, startIndex);
+                            clickableArea.addAll(Arrays.asList(clickableAreasForSubSeries));
+                        }
+                    }
+                }
+            }
+
+            this.drawBackground(this.mRenderer, canvas, x, bottom, width, height - bottom, paint, true, this.mRenderer.getMarginsColor());
+            this.drawBackground(this.mRenderer, canvas, x, y, width, margins[0], paint, true, this.mRenderer.getMarginsColor());
+            if (or == XYMultipleSeriesRenderer.Orientation.HORIZONTAL) {
+                this.drawBackground(this.mRenderer, canvas, x, y, left - x, height - y, paint, true, this.mRenderer.getMarginsColor());
+                this.drawBackground(this.mRenderer, canvas, right, y, margins[3], height - y, paint, true, this.mRenderer.getMarginsColor());
+            } else if (or == XYMultipleSeriesRenderer.Orientation.VERTICAL) {
+                this.drawBackground(this.mRenderer, canvas, right, y, width - right, height - y, paint, true, this.mRenderer.getMarginsColor());
+                this.drawBackground(this.mRenderer, canvas, x, y, left - x, height - y, paint, true, this.mRenderer.getMarginsColor());
+            }
+
+            boolean showLabels = this.mRenderer.isShowLabels() && hasValues;
+            boolean showGridX = this.mRenderer.isShowGridX();
+            boolean showTickMarks = this.mRenderer.isShowTickMarks();
+            boolean showCustomTextGridY = this.mRenderer.isShowCustomTextGridY();
+            if (showLabels || showGridX) {
+                List<Double> xLabels = this.getValidLabels(this.getXLabels(minX[0], maxX[0], this.mRenderer.getXLabels()));
+                Map<Integer, List<Double>> allYLabels = this.getYLabels(minY, maxY, maxScaleNumber);
+                if (showLabels) {
+                    paint.setColor(this.mRenderer.getXLabelsColor());
+                    paint.setTextSize(this.mRenderer.getLabelsTextSize());
+                    paint.setTextAlign(this.mRenderer.getXLabelsAlign());
+                }
+
+                this.drawXLabels(xLabels, this.mRenderer.getXTextLabelLocations(), canvas, paint, left, top, bottom, xPixelsPerUnit[0], minX[0], maxX[0]);
+                this.drawYLabels(allYLabels, canvas, paint, maxScaleNumber, left, right, bottom, yPixelsPerUnit, minY);
+                if (showLabels) {
+                    paint.setColor(this.mRenderer.getLabelsColor());
+
+                    for (i = 0; i < maxScaleNumber; ++i) {
+                        Align axisAlign = this.mRenderer.getYAxisAlign(i);
+                        Double[] yTextLabelLocations = this.mRenderer.getYTextLabelLocations(i);
+                        Double[] arr$ = yTextLabelLocations;
+                        len$ = yTextLabelLocations.length;
+
+                        for (int i$ = 0; i$ < len$; ++i$) {
+                            Double location = arr$[i$];
+                            if (minY[i] <= location && location <= maxY[i]) {
+                                yLabel = (float) ((double) bottom - yPixelsPerUnit[i] * (location - minY[i]));
+                                String label = this.mRenderer.getYTextLabel(location, i);
+                                paint.setColor(this.mRenderer.getYLabelsColor(i));
+                                paint.setTextAlign(this.mRenderer.getYLabelsAlign(i));
+                                if (or == XYMultipleSeriesRenderer.Orientation.HORIZONTAL) {
+                                    if (axisAlign == Align.LEFT) {
+                                        if (showTickMarks) {
+                                            canvas.drawLine((float) (left + this.getLabelLinePos(axisAlign)), yLabel, (float) left, yLabel, paint);
+                                        }
+
+                                        this.drawText(canvas, label, (float) left - this.mRenderer.getYLabelsPadding(), yLabel - this.mRenderer.getYLabelsVerticalPadding(), paint, this.mRenderer.getYLabelsAngle());
+                                    } else {
+                                        if (showTickMarks) {
+                                            canvas.drawLine((float) right, yLabel, (float) (right + this.getLabelLinePos(axisAlign)), yLabel, paint);
+                                        }
+
+                                        this.drawText(canvas, label, (float) right - this.mRenderer.getYLabelsPadding(), yLabel - this.mRenderer.getYLabelsVerticalPadding(), paint, this.mRenderer.getYLabelsAngle());
+                                    }
+
+                                    if (showCustomTextGridY) {
+                                        paint.setColor(this.mRenderer.getGridColor(i));
+                                        canvas.drawLine((float) left, yLabel, (float) right, yLabel, paint);
+                                    }
+                                } else {
+                                    if (showTickMarks) {
+                                        canvas.drawLine((float) (right - this.getLabelLinePos(axisAlign)), yLabel, (float) right, yLabel, paint);
+                                    }
+
+                                    this.drawText(canvas, label, (float) (right + 10), yLabel - this.mRenderer.getYLabelsVerticalPadding(), paint, this.mRenderer.getYLabelsAngle());
+                                    if (showCustomTextGridY) {
+                                        paint.setColor(this.mRenderer.getGridColor(i));
+                                        canvas.drawLine((float) right, yLabel, (float) left, yLabel, paint);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (showLabels) {
+                    paint.setColor(this.mRenderer.getLabelsColor());
+                    float size = this.mRenderer.getAxisTitleTextSize();
+                    paint.setTextSize(size);
+                    paint.setTextAlign(Align.CENTER);
+                    if (or == XYMultipleSeriesRenderer.Orientation.HORIZONTAL) {
+                        this.drawText(canvas, this.mRenderer.getXTitle(), (float) (x + width / 2), (float) bottom + this.mRenderer.getLabelsTextSize() * 4.0F / 3.0F + this.mRenderer.getXLabelsPadding() + size, paint, 0.0F);
+
+                        for (i = 0; i < maxScaleNumber; ++i) {
+                            Align axisAlign = this.mRenderer.getYAxisAlign(i);
+                            if (axisAlign == Align.LEFT) {
+                                this.drawText(canvas, this.mRenderer.getYTitle(i), (float) x + size, (float) (y + height / 2), paint, -90.0F);
+                            } else {
+                                this.drawText(canvas, this.mRenderer.getYTitle(i), (float) (x + width), (float) (y + height / 2), paint, -90.0F);
+                            }
+                        }
+
+                        paint.setTextSize(this.mRenderer.getChartTitleTextSize());
+                        this.drawText(canvas, this.mRenderer.getChartTitle(), (float) (x + width / 2), (float) y + this.mRenderer.getChartTitleTextSize(), paint, 0.0F);
+                    } else if (or == XYMultipleSeriesRenderer.Orientation.VERTICAL) {
+                        this.drawText(canvas, this.mRenderer.getXTitle(), (float) (x + width / 2), (float) (y + height) - size + this.mRenderer.getXLabelsPadding(), paint, -90.0F);
+                        this.drawText(canvas, this.mRenderer.getYTitle(), (float) (right + 20), (float) (y + height / 2), paint, 0.0F);
+                        paint.setTextSize(this.mRenderer.getChartTitleTextSize());
+                        this.drawText(canvas, this.mRenderer.getChartTitle(), (float) x + size, (float) (top + height / 2), paint, 0.0F);
+                    }
+                }
+            }
+
+            if (or == XYMultipleSeriesRenderer.Orientation.HORIZONTAL) {
+                this.drawLegend(canvas, this.mRenderer, titles, left, right, y + (int) this.mRenderer.getXLabelsPadding(), width, height, legendSize, paint, false);
+            } else if (or == XYMultipleSeriesRenderer.Orientation.VERTICAL) {
+                this.transform(canvas, (float) angle, true);
+                this.drawLegend(canvas, this.mRenderer, titles, left, right, y + (int) this.mRenderer.getXLabelsPadding(), width, height, legendSize, paint, false);
+                this.transform(canvas, (float) angle, false);
+            }
+
+            if (this.mRenderer.isShowAxes()) {
+                paint.setColor(this.mRenderer.getXAxisColor());
+                canvas.drawLine((float) left, (float) bottom, (float) right, (float) bottom, paint);
+                paint.setColor(this.mRenderer.getYAxisColor());
+                boolean rightAxis = false;
+
+                for (i = 0; i < maxScaleNumber && !rightAxis; ++i) {
+                    rightAxis = this.mRenderer.getYAxisAlign(i) == Align.RIGHT;
+                }
+
+                if (or == XYMultipleSeriesRenderer.Orientation.HORIZONTAL) {
+                    canvas.drawLine((float) left, (float) top, (float) left, (float) bottom, paint);
+                    if (rightAxis) {
+                        canvas.drawLine((float) right, (float) top, (float) right, (float) bottom, paint);
+                    }
+                } else if (or == XYMultipleSeriesRenderer.Orientation.VERTICAL) {
+                    canvas.drawLine((float) right, (float) top, (float) right, (float) bottom, paint);
+                }
+            }
+
+            if (rotate) {
+                this.transform(canvas, (float) angle, true);
+            }
+
+        }
+    }
+
+    protected List<Double> getXLabels(double min, double max, int count) {
+        return MathHelper.getLabels(min, max, count);
+    }
+
+    protected Map<Integer, List<Double>> getYLabels(double[] minY, double[] maxY, int maxScaleNumber) {
+        Map<Integer, List<Double>> allYLabels = new HashMap();
+
+        for (int i = 0; i < maxScaleNumber; ++i) {
+            allYLabels.put(i, this.getValidLabels(MathHelper.getLabels(minY[i], maxY[i], this.mRenderer.getYLabels())));
+        }
+
+        return allYLabels;
+    }
+
+    protected Rect getScreenR() {
+        return this.mScreenR;
+    }
+
+    protected void setScreenR(Rect screenR) {
+        this.mScreenR = screenR;
+    }
+
+    private List<Double> getValidLabels(List<Double> labels) {
+        List<Double> result = new ArrayList(labels);
+        Iterator i$ = labels.iterator();
+
+        while (i$.hasNext()) {
+            Double label = (Double) i$.next();
+            if (label.isNaN()) {
+                result.remove(label);
+            }
+        }
+
+        return result;
+    }
+
+    protected void drawSeries(XYSeries series, Canvas canvas, Paint paint, List<Float> pointsList, XYSeriesRenderer seriesRenderer, float yAxisValue, int seriesIndex, XYMultipleSeriesRenderer.Orientation or, int startIndex) {
+        BasicStroke stroke = seriesRenderer.getStroke();
+        Cap cap = paint.getStrokeCap();
+        Join join = paint.getStrokeJoin();
+        float miter = paint.getStrokeMiter();
+        PathEffect pathEffect = paint.getPathEffect();
+        Style style = paint.getStyle();
+        if (stroke != null) {
+            PathEffect effect = null;
+            if (stroke.getIntervals() != null) {
+                effect = new DashPathEffect(stroke.getIntervals(), stroke.getPhase());
+            }
+
+            this.setStroke(stroke.getCap(), stroke.getJoin(), stroke.getMiter(), Style.FILL_AND_STROKE, effect, paint);
+        }
+
+        this.drawSeries(canvas, paint, pointsList, seriesRenderer, yAxisValue, seriesIndex, startIndex);
+        this.drawPoints(canvas, paint, pointsList, seriesRenderer, yAxisValue, seriesIndex, startIndex);
+        paint.setTextSize(seriesRenderer.getChartValuesTextSize());
+        if (or == XYMultipleSeriesRenderer.Orientation.HORIZONTAL) {
+            paint.setTextAlign(Align.CENTER);
+        } else {
+            paint.setTextAlign(Align.LEFT);
+        }
+
+        if (seriesRenderer.isDisplayChartValues()) {
+            paint.setTextAlign(seriesRenderer.getChartValuesTextAlign());
+            this.drawChartValuesText(canvas, series, seriesRenderer, paint, pointsList, seriesIndex, startIndex);
+        }
+
+        if (stroke != null) {
+            this.setStroke(cap, join, miter, style, pathEffect, paint);
+        }
+
+    }
+
+    protected void drawPoints(Canvas canvas, Paint paint, List<Float> pointsList, XYSeriesRenderer seriesRenderer, float yAxisValue, int seriesIndex, int startIndex) {
+        if (this.isRenderPoints(seriesRenderer)) {
+            ScatterChart pointsChart = this.getPointsChart();
+            if (pointsChart != null) {
+                pointsChart.drawSeries(canvas, paint, pointsList, seriesRenderer, yAxisValue, seriesIndex, startIndex);
+            }
+        }
+
+    }
+
+    private void setStroke(Cap cap, Join join, float miter, Style style, PathEffect pathEffect, Paint paint) {
+        paint.setStrokeCap(cap);
+        paint.setStrokeJoin(join);
+        paint.setStrokeMiter(miter);
+        paint.setPathEffect(pathEffect);
+        paint.setStyle(style);
+    }
+
+    protected void drawChartValuesText(Canvas canvas, XYSeries series, XYSeriesRenderer renderer, Paint paint, List<Float> points, int seriesIndex, int startIndex) {
+        if (points.size() > 2) {
+            float previousPointX = (Float) points.get(0);
+            float previousPointY = (Float) points.get(1);
+
+            for (int k = 0; k < points.size(); k += 2) {
+                if (k == 2) {
+                    if (Math.abs((Float) points.get(2) - (Float) points.get(0)) > (float) renderer.getDisplayChartValuesDistance() || Math.abs((Float) points.get(3) - (Float) points.get(1)) > (float) renderer.getDisplayChartValuesDistance()) {
+                        this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), series.getY(startIndex)), (Float) points.get(0), (Float) points.get(1) - renderer.getChartValuesSpacing(), paint, 0.0F);
+                        this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), series.getY(startIndex + 1)), (Float) points.get(2), (Float) points.get(3) - renderer.getChartValuesSpacing(), paint, 0.0F);
+                        previousPointX = (Float) points.get(2);
+                        previousPointY = (Float) points.get(3);
+                    }
+                } else if (k > 2 && (Math.abs((Float) points.get(k) - previousPointX) > (float) renderer.getDisplayChartValuesDistance() || Math.abs((Float) points.get(k + 1) - previousPointY) > (float) renderer.getDisplayChartValuesDistance())) {
+                    this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), series.getY(startIndex + k / 2)), (Float) points.get(k), (Float) points.get(k + 1) - renderer.getChartValuesSpacing(), paint, 0.0F);
+                    previousPointX = (Float) points.get(k);
+                    previousPointY = (Float) points.get(k + 1);
+                }
+            }
+        } else {
+            for (int k = 0; k < points.size(); k += 2) {
+                this.drawText(canvas, this.getLabel(renderer.getChartValuesFormat(), series.getY(startIndex + k / 2)), (Float) points.get(k), (Float) points.get(k + 1) - renderer.getChartValuesSpacing(), paint, 0.0F);
+            }
+        }
+
+    }
+
+    protected void drawText(Canvas canvas, String text, float x, float y, Paint paint, float extraAngle) {
+        float angle = (float) (-this.mRenderer.getOrientation().getAngle()) + extraAngle;
+        if (angle != 0.0F) {
+            canvas.rotate(angle, x, y);
+        }
+
+        this.drawString(canvas, text, x, y, paint);
+        if (angle != 0.0F) {
+            canvas.rotate(-angle, x, y);
+        }
+
+    }
+
+    private void transform(Canvas canvas, float angle, boolean inverse) {
+        if (inverse) {
+            canvas.scale(1.0F / this.mScale, this.mScale);
+            canvas.translate(this.mTranslate, -this.mTranslate);
+            canvas.rotate(-angle, this.mCenter.getX(), this.mCenter.getY());
+        } else {
+            canvas.rotate(angle, this.mCenter.getX(), this.mCenter.getY());
+            canvas.translate(-this.mTranslate, this.mTranslate);
+            canvas.scale(this.mScale, 1.0F / this.mScale);
+        }
+
+    }
+
+    protected void drawXLabels(List<Double> xLabels, Double[] xTextLabelLocations, Canvas canvas, Paint paint, int left, int top, int bottom, double xPixelsPerUnit, double minX, double maxX) {
+        int length = xLabels.size();
+        boolean showLabels = this.mRenderer.isShowLabels();
+        boolean showGridY = this.mRenderer.isShowGridY();
+        boolean showTickMarks = this.mRenderer.isShowTickMarks();
+
+        for (int i = 0; i < length; ++i) {
+            double label = (Double) xLabels.get(i);
+            float xLabel = (float) ((double) left + xPixelsPerUnit * (label - minX));
+            if (showLabels) {
+                paint.setColor(this.mRenderer.getXLabelsColor());
+                if (showTickMarks) {
+                    canvas.drawLine(xLabel, (float) bottom, xLabel, (float) bottom + this.mRenderer.getLabelsTextSize() / 3.0F, paint);
+                }
+
+                this.drawText(canvas, this.getLabel(this.mRenderer.getXLabelFormat(), label), xLabel, (float) bottom + this.mRenderer.getLabelsTextSize() * 4.0F / 3.0F + this.mRenderer.getXLabelsPadding(), paint, this.mRenderer.getXLabelsAngle());
+            }
+
+            if (showGridY) {
+                paint.setColor(this.mRenderer.getGridColor(0));
+                canvas.drawLine(xLabel, (float) bottom, xLabel, (float) top, paint);
+            }
+        }
+
+        this.drawXTextLabels(xTextLabelLocations, canvas, paint, showLabels, left, top, bottom, xPixelsPerUnit, minX, maxX);
+    }
+
+    protected void drawYLabels(Map<Integer, List<Double>> allYLabels, Canvas canvas, Paint paint, int maxScaleNumber, int left, int right, int bottom, double[] yPixelsPerUnit, double[] minY) {
+        XYMultipleSeriesRenderer.Orientation or = this.mRenderer.getOrientation();
+        boolean showGridX = this.mRenderer.isShowGridX();
+        boolean showLabels = this.mRenderer.isShowLabels();
+        boolean showTickMarks = this.mRenderer.isShowTickMarks();
+
+        for (int i = 0; i < maxScaleNumber; ++i) {
+            paint.setTextAlign(this.mRenderer.getYLabelsAlign(i));
+            List<Double> yLabels = (List) allYLabels.get(i);
+            int length = yLabels.size();
+
+            for (int j = 0; j < length; ++j) {
+                double label = (Double) yLabels.get(j);
+                Align axisAlign = this.mRenderer.getYAxisAlign(i);
+                boolean textLabel = this.mRenderer.getYTextLabel(label, i) != null;
+                float yLabel = (float) ((double) bottom - yPixelsPerUnit[i] * (label - minY[i]));
+                if (or == XYMultipleSeriesRenderer.Orientation.HORIZONTAL) {
+                    if (showLabels && !textLabel) {
+                        paint.setColor(this.mRenderer.getYLabelsColor(i));
+                        if (axisAlign == Align.LEFT) {
+                            if (showTickMarks) {
+                                canvas.drawLine((float) (left + this.getLabelLinePos(axisAlign)), yLabel, (float) left, yLabel, paint);
+                            }
+
+                            this.drawText(canvas, this.getLabel(this.mRenderer.getYLabelFormat(i), label), (float) left - this.mRenderer.getYLabelsPadding(), yLabel - this.mRenderer.getYLabelsVerticalPadding(), paint, this.mRenderer.getYLabelsAngle());
+                        } else {
+                            if (showTickMarks) {
+                                canvas.drawLine((float) right, yLabel, (float) (right + this.getLabelLinePos(axisAlign)), yLabel, paint);
+                            }
+
+                            this.drawText(canvas, this.getLabel(this.mRenderer.getYLabelFormat(i), label), (float) right + this.mRenderer.getYLabelsPadding(), yLabel - this.mRenderer.getYLabelsVerticalPadding(), paint, this.mRenderer.getYLabelsAngle());
+                        }
+                    }
+
+                    if (showGridX) {
+                        paint.setColor(this.mRenderer.getGridColor(i));
+                        canvas.drawLine((float) left, yLabel, (float) right, yLabel, paint);
+                    }
+                } else if (or == XYMultipleSeriesRenderer.Orientation.VERTICAL) {
+                    if (showLabels && !textLabel) {
+                        paint.setColor(this.mRenderer.getYLabelsColor(i));
+                        if (showTickMarks) {
+                            canvas.drawLine((float) (right - this.getLabelLinePos(axisAlign)), yLabel, (float) right, yLabel, paint);
+                        }
+
+                        this.drawText(canvas, this.getLabel(this.mRenderer.getLabelFormat(), label), (float) (right + 10) + this.mRenderer.getYLabelsPadding(), yLabel - this.mRenderer.getYLabelsVerticalPadding(), paint, this.mRenderer.getYLabelsAngle());
+                    }
+
+                    if (showGridX) {
+                        paint.setColor(this.mRenderer.getGridColor(i));
+                        if (showTickMarks) {
+                            canvas.drawLine((float) right, yLabel, (float) left, yLabel, paint);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    protected void drawXTextLabels(Double[] xTextLabelLocations, Canvas canvas, Paint paint, boolean showLabels, int left, int top, int bottom, double xPixelsPerUnit, double minX, double maxX) {
+        boolean showCustomTextGridX = this.mRenderer.isShowCustomTextGridX();
+        boolean showTickMarks = this.mRenderer.isShowTickMarks();
+        if (showLabels) {
+            paint.setColor(this.mRenderer.getXLabelsColor());
+            Double[] arr$ = xTextLabelLocations;
+            int len$ = xTextLabelLocations.length;
+
+            for (int i$ = 0; i$ < len$; ++i$) {
+                Double location = arr$[i$];
+                if (minX <= location && location <= maxX) {
+                    float xLabel = (float) ((double) left + xPixelsPerUnit * (location - minX));
+                    paint.setColor(this.mRenderer.getXLabelsColor());
+                    if (showTickMarks) {
+                        canvas.drawLine(xLabel, (float) bottom, xLabel, (float) bottom + this.mRenderer.getLabelsTextSize() / 3.0F, paint);
+                    }
+
+                    this.drawText(canvas, this.mRenderer.getXTextLabel(location), xLabel, (float) bottom + this.mRenderer.getLabelsTextSize() * 4.0F / 3.0F + this.mRenderer.getXLabelsPadding(), paint, this.mRenderer.getXLabelsAngle());
+                    if (showCustomTextGridX) {
+                        paint.setColor(this.mRenderer.getGridColor(0));
+                        canvas.drawLine(xLabel, (float) bottom, xLabel, (float) top, paint);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public XYMultipleSeriesRenderer getRenderer() {
+        return this.mRenderer;
+    }
+
+    public XYMultipleSeriesDataset getDataset() {
+        return this.mDataset;
+    }
+
+    public double[] getCalcRange(int scale) {
+        return (double[]) this.mCalcRange.get(scale);
+    }
+
+    public void setCalcRange(double[] range, int scale) {
+        this.mCalcRange.put(scale, range);
+    }
+
+    public double[] toRealPoint(float screenX, float screenY) {
+        return this.toRealPoint(screenX, screenY, 0);
+    }
+
+    public double[] toScreenPoint(double[] realPoint) {
+        return this.toScreenPoint(realPoint, 0);
+    }
+
+    private int getLabelLinePos(Align align) {
+        int pos = 4;
+        if (align == Align.LEFT) {
+            pos = -pos;
+        }
+
+        return pos;
+    }
+
+    public double[] toRealPoint(float screenX, float screenY, int scale) {
+        double realMinX = this.mRenderer.getXAxisMin(scale);
+        double realMaxX = this.mRenderer.getXAxisMax(scale);
+        double realMinY = this.mRenderer.getYAxisMin(scale);
+        double realMaxY = this.mRenderer.getYAxisMax(scale);
+        if (!this.mRenderer.isMinXSet(scale) || !this.mRenderer.isMaxXSet(scale) || !this.mRenderer.isMinYSet(scale) || !this.mRenderer.isMaxYSet(scale)) {
+            double[] calcRange = this.getCalcRange(scale);
+            if (calcRange != null) {
+                realMinX = calcRange[0];
+                realMaxX = calcRange[1];
+                realMinY = calcRange[2];
+                realMaxY = calcRange[3];
+            }
+        }
+
+        return this.mScreenR != null ? new double[]{(double) (screenX - (float) this.mScreenR.left) * (realMaxX - realMinX) / (double) this.mScreenR.width() + realMinX, (double) ((float) (this.mScreenR.top + this.mScreenR.height()) - screenY) * (realMaxY - realMinY) / (double) this.mScreenR.height() + realMinY} : new double[]{(double) screenX, (double) screenY};
+    }
+
+    public double[] toScreenPoint(double[] realPoint, int scale) {
+        double realMinX = this.mRenderer.getXAxisMin(scale);
+        double realMaxX = this.mRenderer.getXAxisMax(scale);
+        double realMinY = this.mRenderer.getYAxisMin(scale);
+        double realMaxY = this.mRenderer.getYAxisMax(scale);
+        if (!this.mRenderer.isMinXSet(scale) || !this.mRenderer.isMaxXSet(scale) || !this.mRenderer.isMinYSet(scale) || !this.mRenderer.isMaxYSet(scale)) {
+            double[] calcRange = this.getCalcRange(scale);
+            realMinX = calcRange[0];
+            realMaxX = calcRange[1];
+            realMinY = calcRange[2];
+            realMaxY = calcRange[3];
+        }
+
+        return this.mScreenR != null ? new double[]{(realPoint[0] - realMinX) * (double) this.mScreenR.width() / (realMaxX - realMinX) + (double) this.mScreenR.left, (realMaxY - realPoint[1]) * (double) this.mScreenR.height() / (realMaxY - realMinY) + (double) this.mScreenR.top} : realPoint;
+    }
+
+    public SeriesSelection getSeriesAndPointForScreenCoordinate(Point screenPoint) {
+        if (this.clickableAreas != null) {
+            for (int seriesIndex = this.clickableAreas.size() - 1; seriesIndex >= 0; --seriesIndex) {
+                int pointIndex = 0;
+                if (this.clickableAreas.get(seriesIndex) != null) {
+                    for (Iterator i$ = ((List) this.clickableAreas.get(seriesIndex)).iterator(); i$.hasNext(); ++pointIndex) {
+                        ClickableArea area = (ClickableArea) i$.next();
+                        if (area != null) {
+                            RectF rectangle = area.getRect();
+                            if (rectangle != null && rectangle.contains(screenPoint.getX(), screenPoint.getY())) {
+                                return new SeriesSelection(seriesIndex, pointIndex, area.getX(), area.getY());
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return super.getSeriesAndPointForScreenCoordinate(screenPoint);
+    }
+
+    public abstract void drawSeries(Canvas var1, Paint var2, List<Float> var3, XYSeriesRenderer var4, float var5, int var6, int var7);
+
+    protected abstract ClickableArea[] clickableAreasForPoints(List<Float> var1, List<Double> var2, float var3, int var4, int var5);
+
+    protected boolean isRenderNullValues() {
+        return false;
+    }
+
+    public boolean isRenderPoints(SimpleSeriesRenderer renderer) {
+        return false;
+    }
+
+    public double getDefaultMinimum() {
+        return 1.7976931348623157E308D;
+    }
+
+    public ScatterChart getPointsChart() {
+        return null;
+    }
+
+    public abstract String getChartType();
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/LineChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/LineChart.java	(date 1580289897000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/LineChart.java	(date 1580289897000)
@@ -0,0 +1,180 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.RectF;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
+public class LineChart extends XYChart {
+    public static final String TYPE = "Line";
+    private static final int SHAPE_WIDTH = 30;
+    private ScatterChart pointsChart;
+
+    LineChart() {
+    }
+
+    public LineChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        super(dataset, renderer);
+        this.pointsChart = new ScatterChart(dataset, renderer);
+    }
+
+    protected void setDatasetRenderer(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        super.setDatasetRenderer(dataset, renderer);
+        this.pointsChart = new ScatterChart(dataset, renderer);
+    }
+
+    public void drawSeries(Canvas canvas, Paint paint, List<Float> points, XYSeriesRenderer renderer, float yAxisValue, int seriesIndex, int startIndex) {
+        float lineWidth = paint.getStrokeWidth();
+        paint.setStrokeWidth(renderer.getLineWidth());
+        XYSeriesRenderer.FillOutsideLine[] fillOutsideLine = renderer.getFillOutsideLine();
+        XYSeriesRenderer.FillOutsideLine[] arr$ = fillOutsideLine;
+        int len$ = fillOutsideLine.length;
+
+        for (int i$ = 0; i$ < len$; ++i$) {
+            XYSeriesRenderer.FillOutsideLine fill = arr$[i$];
+            if (fill.getType() != XYSeriesRenderer.FillOutsideLine.Type.NONE) {
+                paint.setColor(fill.getColor());
+                List<Float> fillPoints = new ArrayList();
+                int[] range = fill.getFillRange();
+                if (range == null) {
+                    fillPoints.addAll(points);
+                } else if (points.size() > range[0] * 2 && points.size() > range[1] * 2) {
+                    fillPoints.addAll(points.subList(range[0] * 2, range[1] * 2));
+                }
+
+                float referencePoint;
+                switch (fill.getType()) {
+                    case BOUNDS_ALL:
+                        referencePoint = yAxisValue;
+                        break;
+                    case BOUNDS_BELOW:
+                        referencePoint = yAxisValue;
+                        break;
+                    case BOUNDS_ABOVE:
+                        referencePoint = yAxisValue;
+                        break;
+                    case BELOW:
+                        referencePoint = (float) canvas.getHeight();
+                        break;
+                    case ABOVE:
+                        referencePoint = 0.0F;
+                        break;
+                    default:
+                        throw new RuntimeException("You have added a new type of filling but have not implemented.");
+                }
+
+                if (fill.getType() == XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_ABOVE || fill.getType() == XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_BELOW) {
+                    List<Float> boundsPoints = new ArrayList();
+                    boolean add = false;
+                    int length = fillPoints.size();
+                    if (length > 0 && fill.getType() == XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_ABOVE && (Float) fillPoints.get(1) < referencePoint || fill.getType() == XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_BELOW && (Float) fillPoints.get(1) > referencePoint) {
+                        boundsPoints.add(fillPoints.get(0));
+                        boundsPoints.add(fillPoints.get(1));
+                        add = true;
+                    }
+
+                    for (int i = 3; i < length; i += 2) {
+                        float prevValue = (Float) fillPoints.get(i - 2);
+                        float value = (Float) fillPoints.get(i);
+                        if (prevValue < referencePoint && value > referencePoint || prevValue > referencePoint && value < referencePoint) {
+                            float prevX = (Float) fillPoints.get(i - 3);
+                            float x = (Float) fillPoints.get(i - 1);
+                            boundsPoints.add(prevX + (x - prevX) * (referencePoint - prevValue) / (value - prevValue));
+                            boundsPoints.add(referencePoint);
+                            if ((fill.getType() != XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_ABOVE || value <= referencePoint) && (fill.getType() != XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_BELOW || value >= referencePoint)) {
+                                boundsPoints.add(x);
+                                boundsPoints.add(value);
+                                add = true;
+                            } else {
+                                i += 2;
+                                add = false;
+                            }
+                        } else if (add || fill.getType() == XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_ABOVE && value < referencePoint || fill.getType() == XYSeriesRenderer.FillOutsideLine.Type.BOUNDS_BELOW && value > referencePoint) {
+                            boundsPoints.add(fillPoints.get(i - 1));
+                            boundsPoints.add(value);
+                        }
+                    }
+
+                    fillPoints.clear();
+                    fillPoints.addAll(boundsPoints);
+                }
+
+                int length = fillPoints.size();
+                if (length > 0) {
+                    fillPoints.set(0, fillPoints.get(0) + 1.0F);
+                    fillPoints.add(fillPoints.get(length - 2));
+                    fillPoints.add(referencePoint);
+                    fillPoints.add(fillPoints.get(0));
+                    fillPoints.add(fillPoints.get(length + 1));
+
+                    for (int i = 0; i < length + 4; i += 2) {
+                        if (fillPoints.get(i + 1) < 0.0F) {
+                            fillPoints.set(i + 1, 0.0F);
+                        }
+                    }
+
+                    paint.setStyle(Style.FILL);
+                    this.drawPath(canvas, fillPoints, paint, true);
+                }
+            }
+        }
+
+        paint.setColor(renderer.getColor());
+        paint.setStyle(Style.STROKE);
+        this.drawPath(canvas, points, paint, false);
+        paint.setStrokeWidth(lineWidth);
+    }
+
+    protected ClickableArea[] clickableAreasForPoints(List<Float> points, List<Double> values, float yAxisValue, int seriesIndex, int startIndex) {
+        int length = points.size();
+        ClickableArea[] ret = new ClickableArea[length / 2];
+
+        for (int i = 0; i < length; i += 2) {
+            int selectableBuffer = this.mRenderer.getSelectableBuffer();
+            ret[i / 2] = new ClickableArea(new RectF((Float) points.get(i) - (float) selectableBuffer, (Float) points.get(i + 1) - (float) selectableBuffer, (Float) points.get(i) + (float) selectableBuffer, (Float) points.get(i + 1) + (float) selectableBuffer), (Double) values.get(i), (Double) values.get(i + 1));
+        }
+
+        return ret;
+    }
+
+    public int getLegendShapeWidth(int seriesIndex) {
+        return 30;
+    }
+
+    public void drawLegendShape(Canvas canvas, SimpleSeriesRenderer renderer, float x, float y, int seriesIndex, Paint paint) {
+        float oldWidth = paint.getStrokeWidth();
+        paint.setStrokeWidth(((XYSeriesRenderer) renderer).getLineWidth());
+        canvas.drawLine(x, y, x + 30.0F, y, paint);
+        paint.setStrokeWidth(oldWidth);
+        if (this.isRenderPoints(renderer)) {
+            this.pointsChart.drawLegendShape(canvas, renderer, x + 5.0F, y, seriesIndex, paint);
+        }
+
+    }
+
+    public boolean isRenderPoints(SimpleSeriesRenderer renderer) {
+        return ((XYSeriesRenderer) renderer).getPointStyle() != PointStyle.POINT;
+
+    }
+
+    public ScatterChart getPointsChart() {
+        return this.pointsChart;
+    }
+
+    public String getChartType() {
+        return "Line";
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/ScatterChart.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/ScatterChart.java	(date 1580289897000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/ScatterChart.java	(date 1580289897000)
@@ -0,0 +1,204 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.RectF;
+
+import java.util.List;
+
+import www.jingkan.com.view.chart.achartengine.model.XYMultipleSeriesDataset;
+import www.jingkan.com.view.chart.achartengine.renderer.SimpleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYMultipleSeriesRenderer;
+import www.jingkan.com.view.chart.achartengine.renderer.XYSeriesRenderer;
+
+public class ScatterChart extends XYChart {
+    public static final String TYPE = "Scatter";
+    private static final float SIZE = 3.0F;
+    private static final int SHAPE_WIDTH = 10;
+    private float size = 3.0F;
+
+    ScatterChart() {
+    }
+
+    public ScatterChart(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        super(dataset, renderer);
+        this.size = renderer.getPointSize();
+    }
+
+    protected void setDatasetRenderer(XYMultipleSeriesDataset dataset, XYMultipleSeriesRenderer renderer) {
+        super.setDatasetRenderer(dataset, renderer);
+        this.size = renderer.getPointSize();
+    }
+
+    public void drawSeries(Canvas canvas, Paint paint, List<Float> points, XYSeriesRenderer renderer, float yAxisValue, int seriesIndex, int startIndex) {
+        paint.setColor(renderer.getColor());
+        float stroke = paint.getStrokeWidth();
+        if (renderer.isFillPoints()) {
+            paint.setStyle(Style.FILL);
+        } else {
+            paint.setStrokeWidth(renderer.getPointStrokeWidth());
+            paint.setStyle(Style.STROKE);
+        }
+
+        int length = points.size();
+        float[] path;
+        int i;
+        label63:
+        switch (renderer.getPointStyle()) {
+            case X:
+                paint.setStrokeWidth(renderer.getPointStrokeWidth());
+                i = 0;
+
+                while (true) {
+                    if (i >= length) {
+                        break label63;
+                    }
+
+                    this.drawX(canvas, paint, (Float) points.get(i), (Float) points.get(i + 1));
+                    i += 2;
+                }
+            case CIRCLE:
+                i = 0;
+
+                while (true) {
+                    if (i >= length) {
+                        break label63;
+                    }
+
+                    this.drawCircle(canvas, paint, (Float) points.get(i), (Float) points.get(i + 1));
+                    i += 2;
+                }
+            case TRIANGLE:
+                path = new float[6];
+                i = 0;
+
+                while (true) {
+                    if (i >= length) {
+                        break label63;
+                    }
+
+                    this.drawTriangle(canvas, paint, path, (Float) points.get(i), (Float) points.get(i + 1));
+                    i += 2;
+                }
+            case SQUARE:
+                i = 0;
+
+                while (true) {
+                    if (i >= length) {
+                        break label63;
+                    }
+
+                    this.drawSquare(canvas, paint, (Float) points.get(i), (Float) points.get(i + 1));
+                    i += 2;
+                }
+            case DIAMOND:
+                path = new float[8];
+                i = 0;
+
+                while (true) {
+                    if (i >= length) {
+                        break label63;
+                    }
+
+                    this.drawDiamond(canvas, paint, path, (Float) points.get(i), (Float) points.get(i + 1));
+                    i += 2;
+                }
+            case POINT:
+                for (i = 0; i < length; i += 2) {
+                    canvas.drawPoint((Float) points.get(i), (Float) points.get(i + 1), paint);
+                }
+        }
+
+        paint.setStrokeWidth(stroke);
+    }
+
+    protected ClickableArea[] clickableAreasForPoints(List<Float> points, List<Double> values, float yAxisValue, int seriesIndex, int startIndex) {
+        int length = points.size();
+        ClickableArea[] ret = new ClickableArea[length / 2];
+
+        for (int i = 0; i < length; i += 2) {
+            int selectableBuffer = this.mRenderer.getSelectableBuffer();
+            ret[i / 2] = new ClickableArea(new RectF((Float) points.get(i) - (float) selectableBuffer, (Float) points.get(i + 1) - (float) selectableBuffer, (Float) points.get(i) + (float) selectableBuffer, (Float) points.get(i + 1) + (float) selectableBuffer), (Double) values.get(i), (Double) values.get(i + 1));
+        }
+
+        return ret;
+    }
+
+    public int getLegendShapeWidth(int seriesIndex) {
+        return 10;
+    }
+
+    public void drawLegendShape(Canvas canvas, SimpleSeriesRenderer renderer, float x, float y, int seriesIndex, Paint paint) {
+        if (((XYSeriesRenderer) renderer).isFillPoints()) {
+            paint.setStyle(Style.FILL);
+        } else {
+            paint.setStyle(Style.STROKE);
+        }
+
+        switch (((XYSeriesRenderer) renderer).getPointStyle()) {
+            case X:
+                this.drawX(canvas, paint, x + 10.0F, y);
+                break;
+            case CIRCLE:
+                this.drawCircle(canvas, paint, x + 10.0F, y);
+                break;
+            case TRIANGLE:
+                this.drawTriangle(canvas, paint, new float[6], x + 10.0F, y);
+                break;
+            case SQUARE:
+                this.drawSquare(canvas, paint, x + 10.0F, y);
+                break;
+            case DIAMOND:
+                this.drawDiamond(canvas, paint, new float[8], x + 10.0F, y);
+                break;
+            case POINT:
+                canvas.drawPoint(x + 10.0F, y, paint);
+        }
+
+    }
+
+    private void drawX(Canvas canvas, Paint paint, float x, float y) {
+        canvas.drawLine(x - this.size, y - this.size, x + this.size, y + this.size, paint);
+        canvas.drawLine(x + this.size, y - this.size, x - this.size, y + this.size, paint);
+    }
+
+    private void drawCircle(Canvas canvas, Paint paint, float x, float y) {
+        canvas.drawCircle(x, y, this.size, paint);
+    }
+
+    private void drawTriangle(Canvas canvas, Paint paint, float[] path, float x, float y) {
+        path[0] = x;
+        path[1] = y - this.size - this.size / 2.0F;
+        path[2] = x - this.size;
+        path[3] = y + this.size;
+        path[4] = x + this.size;
+        path[5] = path[3];
+        this.drawPath(canvas, path, paint, true);
+    }
+
+    private void drawSquare(Canvas canvas, Paint paint, float x, float y) {
+        canvas.drawRect(x - this.size, y - this.size, x + this.size, y + this.size, paint);
+    }
+
+    private void drawDiamond(Canvas canvas, Paint paint, float[] path, float x, float y) {
+        path[0] = x;
+        path[1] = y - this.size;
+        path[2] = x - this.size;
+        path[3] = y;
+        path[4] = x;
+        path[5] = y + this.size;
+        path[6] = x + this.size;
+        path[7] = y;
+        this.drawPath(canvas, path, paint, true);
+    }
+
+    public String getChartType() {
+        return "Scatter";
+    }
+}
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/ClickableArea.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/ClickableArea.java	(date 1580267755000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/ClickableArea.java	(date 1580267755000)
@@ -0,0 +1,32 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+import android.graphics.RectF;
+
+public class ClickableArea {
+    private RectF rect;
+    private double x;
+    private double y;
+
+    public ClickableArea(RectF rect, double x, double y) {
+        this.rect = rect;
+        this.x = x;
+        this.y = y;
+    }
+
+    public RectF getRect() {
+        return this.rect;
+    }
+
+    public double getX() {
+        return this.x;
+    }
+
+    public double getY() {
+        return this.y;
+    }
+}
Index: app/src/main/java/www/jingkan/com/view_model/CalibrationParameterVM.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view_model/CalibrationParameterVM.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view_model/CalibrationParameterVM.java	(date 1577188500000)
@@ -27,6 +27,7 @@
 /**
  * Created by Sampson on 2019/1/31.
  * CPTTest
+ * {@link www.jingkan.com.view.CalibrationParameterActivity}
  */
 public class CalibrationParameterVM extends BaseViewModel {
 
Index: app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PointStyle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PointStyle.java	(date 1580377350000)
+++ app/src/main/java/www/jingkan/com/view/chart/achartengine/chart/PointStyle.java	(date 1580377350000)
@@ -0,0 +1,57 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by Fernflower decompiler)
+//
+
+package www.jingkan.com.view.chart.achartengine.chart;
+
+public enum PointStyle {
+    X("x"),
+    CIRCLE("circle"),
+    TRIANGLE("triangle"),
+    SQUARE("square"),
+    DIAMOND("diamond"),
+    POINT("point");
+
+    private String mName;
+
+    private PointStyle(String name) {
+        this.mName = name;
+    }
+
+    public String getName() {
+        return this.mName;
+    }
+
+    public String toString() {
+        return this.getName();
+    }
+
+    public static PointStyle getPointStyleForName(String name) {
+        PointStyle pointStyle = null;
+        PointStyle[] styles = values();
+        int length = styles.length;
+
+        for (int i = 0; i < length && pointStyle == null; ++i) {
+            if (styles[i].mName.equals(name)) {
+                pointStyle = styles[i];
+            }
+        }
+
+        return pointStyle;
+    }
+
+    public static int getIndexForName(String name) {
+        int index = -1;
+        PointStyle[] styles = values();
+        int length = styles.length;
+
+        for (int i = 0; i < length && index < 0; ++i) {
+            if (styles[i].mName.equals(name)) {
+                index = i;
+            }
+        }
+
+        return Math.max(0, index);
+    }
+}
Index: app/src/main/res/layout/activity_calibration_parameter.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/activity_calibration_parameter.xml	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/res/layout/activity_calibration_parameter.xml	(date 1577188500000)
@@ -104,7 +104,7 @@
                 android:layout_toRightOf="@+id/tv_differential"
                 android:background="@android:color/transparent"
                 android:gravity="end|center_vertical"
-                android:inputType="number"
+                android:inputType="numberDecimal"
                 android:paddingRight="24dp"
                 android:text="@={model.lvDifferential}" />
 
Index: app/src/main/java/www/jingkan/com/view_model/AnalogCaCalibrationVerificationVM.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/www/jingkan/com/view_model/AnalogCaCalibrationVerificationVM.java	(revision 8437683cfa3e8a17a0b124841e6071c964c5ea91)
+++ app/src/main/java/www/jingkan/com/view_model/AnalogCaCalibrationVerificationVM.java	(date 1577189052000)
@@ -64,12 +64,7 @@
                 CalibrationProbeEntity calibrationProbeModel = calibrationProbeEntities.get(0);
                 ldNumber.setValue(calibrationProbeModel.number);
                 ldArea.setValue(calibrationProbeModel.work_area);
-                if (isFS) {
-                    ldDifferential.setValue(String.valueOf(Integer.parseInt(calibrationProbeModel.differential) * 10));
-//                    differential = Integer.parseInt(calibrationProbeModel.differential) * 10;
-                } else {
-                    ldDifferential.setValue(String.valueOf(Integer.parseInt(calibrationProbeModel.differential)));
-                }
+                ldDifferential.setValue(calibrationProbeModel.differential);
             }
         });
 
@@ -104,7 +99,7 @@
         } else {
             return;
         }
-        Integer differential = Integer.valueOf(Objects.requireNonNull(ldDifferential.getValue()));
+        float differential = Float.valueOf(Objects.requireNonNull(ldDifferential.getValue()));
         for (int i = 0; i < 3; i++) {
             if (i == 0) {
                 obs.add(i * differential, ra.nextInt(10));
@@ -199,7 +194,7 @@
     private float[] calculationParameter() {
         float[] parameter = new float[6];
         int length = loadAverage.length;
-        int[] perLoad = new int[length];
+        float[] perLoad = new float[length];
         float[] loadUnloadAverage = new float[length];
         float squareSumLoadUnloadAverage = 0;
         float optimumValue;
@@ -212,7 +207,7 @@
         for (int i = 0; i < length; i++) {
             loadUnloadAverage[i] = (loadAverage[i] + unLoadAverage[i]) / 2;
             squareSumLoadUnloadAverage += loadUnloadAverage[i] * loadUnloadAverage[i];
-            int differential = Integer.parseInt(Objects.requireNonNull(ldDifferential.getValue()));
+            float differential = Float.parseFloat(Objects.requireNonNull(ldDifferential.getValue()));
             perLoad[i] = differential * i;
             sumPerLoad += perLoad[i] * loadUnloadAverage[i];
         }
diff --git app/src/main/java/www/jingkan/com/view/chart/achartengine/image/zoom-1.png app/src/main/java/www/jingkan/com/view/chart/achartengine/image/zoom-1.png
new file mode 100644
index 0000000000000000000000000000000000000000..8265f27840a14b4b275086df67af01c73a3a8420
GIT binary patch
literal 1139
zc$@)q1dRKMP)<h;3K|Lk000e1NJLTq000;O000;W1^@s6;CDUv00004XF*Lt006O%
z3;baP00006VoOIv0RI600RN!9r;`8x010qNS#tmY3labT3lag+-G2N4000McNliru
z(g6nx0xO|Pa;^XX1Mo>iK~#9!wU*CoR96(oKljb}2AN4rGl?J?Uud%EMjJ&JKEVVG
z!nl};q=TD^kVeR+1>N}<xDW*Y0^5ZY859hyFm@Ht{E}7;LCG(YhQvW81e(NozwVDN
znhZ(n#8T1&7cTc4&gY)*efQi4|Fel&j!Y(#EtkvrAP8J3<x!;+z#=ew;J|^xix)2j
z{}bTKl`AJ-zkYqkvaHVY=g)Ke_;J$dG+JxQ<uc>r;}nZUq?AL44<EiUHa7O#zXo)5
zb!AJX(nHsE<GsDT96WfCef#zygg|Re6h-*H&%1Z;xPSjXBO@cSp`oF7Zf>q-HL<Np
zE|)twGc)tcrAwFMSFc{Bsi}#&x;h#g8)<54qPe-5bUIBcl_Hf&aqQSJJkPUUy?T{D
za^%R*tE;P}T>)Vj{^+{y=l%Wtq*5sw8X9PBZYGsVkw_$n#bU%_F%pRcb#-+llS$gz
z+L)f6wq|E%zX*ch`<gm+baZ4L$1%lX(Y$%{#*|7WbMfLu6Gf3xN*Se;ky4r{ij433
zW^HZFT)1$-EG;dWLZM*l>+4NpV`KJXxh;Tlxtz~tvm82fh-5NJUtix}PRl|FK{lHu
zm&+l9KnTI*%a^PEj*bp8nGBxi<!b_hAaKu~J&SGIT)TFy>NLje2sXyh)6=tKT?j#U
zcQ;BYw<bU-b+o0Wg+wC3g9i_)$+pJe;2@75KgJltqeqW+0F5!Ux3>cv{TLv=2|x%z
zJRV0Wg)s&pM0LJpN~!9aF@`9LkWvyw(LbvFdj*U0^YhhjU2Bcj8Yv}GN^-dzxm<2X
zvaQ%K44ImmLMgRa6JU%Pe){w&zV8!;AzEvUF@#}A5CmwgQA!bpAz>JzltODw5CjB4
zK(SavYdu_3BFnN0g+k%$d_GTmdwW#|&+`yMaPQtdgb-9J6{M6q{BPgB<;jyL0EOLJ
zg=5?H52sI`?!0^VF1BrBSr)c!BZSy-CQ7Ml%lPo&1J|!#XJTSv2<Y1FCjVhs*2MDi
z@;C3_zqd}DI8oI*2m-<|#PdADFvRzLDwPWB>+9UUeVdVy5ea+;%<S4KwAQu|VrXh=
zD*y83ORJ@&h5h^YSCen)y|J;u<m4o`Zrx&ZbW{Qr;45Gi`1Mom+5yr+h&z^Lb)GwS
zjx%S@(AwGxz}(y%&!0c%*|TQ=L%<E-A@JGeW><i3fuBD0;5fjSKpt?nU7|%`c=JG4
zfMtNz*49ZtEG#ToKm=qq<34H5E@OMl%D})tbn4V84_Moj&DqPR*8$dV-n^+?*OkCJ
zu(6krt*ZQifq}?zoM^8B+aV=D0iA#&_V_Pl`;LDH_!EB+BO_y(@frXC002ovPDHLk
FV1fd66$JnQ

diff --git app/src/main/java/www/jingkan/com/view/chart/achartengine/image/zoom_out.png app/src/main/java/www/jingkan/com/view/chart/achartengine/image/zoom_out.png
new file mode 100644
index 0000000000000000000000000000000000000000..d67a87de533e307cb0e95ab2623259d98eb1adae
GIT binary patch
literal 1074
zc$@(;1kL-2P)<h;3K|Lk000e1NJLTq000;O000;W1^@s6;CDUv00004XF*Lt006O%
z3;baP00006VoOIv0RI600RN!9r;`8x010qNS#tmY3labT3lag+-G2N4000McNliru
z(g6nx1qQ3sxEufg1FuO$K~#9!wU*6GV^<WwfA>ZcG>Ma%D2N{kj*D)b>fpvF=zwm5
z5E-mXb<tU5(=KM`YL>GYn7^T$p^GpsN-Jnrg5T1P7C|(AOa;G)2(2OS^S;-Oc{m-T
zrPvDx4(A=t@1Aow=RWwKkErw^ola*8g~FI=nwsM{ZAvMCBVg&#qer>*_4ObB6JUIN
z{ORWA=36P{z~JB@Po6v>9*^U?E`>sYwY4>7XJ>I7XTG_)`Q_^B>TmxV@a);M%<1Xr
zdri}-Mn^|!Y;2^ux*8z_uIpmkHiltva&p4EckftUUUp)!*y#TLe#LA8Wo2Y!<Y_*i
z|K<7f=T(!FlOz%eqR}Yz_4OnY2^tz2h{xkZA`v2y2%Vjs=(;X9Ha5muT3UX-yu3WU
z6JS}^51OX6zj*P2NF+im7Nen|fk-4mC=?<P2oMMa2!%pKqfx@)FpnQUW_Nd2?(OY;
zX`1Huw*e$TS65fYb=`r9i3w_JYl+2TBoYaN!61P^04XI>N*^MnBpeRY-ri0&o5l0I
zf%^LTOhrJUP#DW(GBh<c5e|o`tE)o@fs_&<#Ak97+SS!XI-N$>^|6Wo(=@fdzCMD%
zAkk<PAq1Z1;d$OC&Sl$8yAXn*p&^t~+HHU;0Hsu0Yilc^P{<EHJUr|NxDAlY<$S%P
zqXVGrE&xIZs;a6`N}-g(^E@AR8$c<AZQD4GgKgWNW&2OS(c$4?dvkL$wrwMXV0wDm
zuXQ=N>$*6OgHj5^FtBYK%d*(n*+D6FRIvx1=Pk|6&0!b@mStg@CYELSdRfXg!!Xcw
z-M7!q&f>c6QbmB2GMCHc$mjFux=yK7Lf7?A#57GxrIIhEX`<^o+uPgB%*+7fDh`@u
zS%wgz`{3XpH8?nk>$+H$<*x_JvaoI2&!P+~7K^-k^@_8zvw2|Zu1Wq=O8NWo@$on3
z=jXD!yW4MGIjFAdetAlz5?5DOym|A6<>h4u_zuY5xhh=O4GJOVcXoEhK79BfTU%SH
zsj2aUm+M_D7TMa`;`Qs-tgNg!KneI7xCDN^Z(S#WxDev4lyacIzn|XTUQ($P0Q>v<
zEG{mxu&@9y54;5417BQU_5%18`02g}CkcE7i~-t>Avyw<t{Zv*90R0MsVzW!{P<A<
zHjuvdyZ0pTkefai*=*MC>FLpdzpl%ce8{Ia30zH0O({*&9N-ElJ|v`^m66S6?PM}(
sKQ!Pb<P=cA0FV?9{Fid`#(x0(4UyyrSYv_X0000007*qoM6N<$f+Vo}uK)l5

diff --git app/src/main/java/www/jingkan/com/view/chart/achartengine/image/zoom_in.png app/src/main/java/www/jingkan/com/view/chart/achartengine/image/zoom_in.png
new file mode 100644
index 0000000000000000000000000000000000000000..1ac4864d4a0c95a022e19ef38b4544711de39f1e
GIT binary patch
literal 1099
zc$@)C1ho5!P)<h;3K|Lk000e1NJLTq000;O000;W1^@s6;CDUv00004XF*Lt006O%
z3;baP00006VoOIv0RI600RN!9r;`8x010qNS#tmY3labT3lag+-G2N4000McNliru
z(g6nx1SkHcnF9a-1IS54K~#9!wU)t49A^~3f8Vz{i|(#&-Bl2yE1E+uS`B(|ged4`
zBd!GNQ9abdUQ#eO{{jy}!2h5<gdUcNlvdE5ghZp#nus8}N>af{SP@!vXJ%)<nO@wf
zZKIZAKX~wX^LW4Sy~lgs!2f*2bsv(+WGa`-jaZhYJC4(!lma*eRw^qiGaDNl-~T7T
z=;-K!w{PD*lT!Bd_4U!(+Da@I!*yM9xg6{3>ntuV;yBK7U0vPNwY9Zh{xzVtw>Ncs
zeEdS!^^)P?VQOk>C@n2T2!ZRm*tU&nntb^1f#=Vkv%0$KM5EE+gM))>vk4THp`oD%
z*=+Ww$B!SEjE|2KkH?8bB2-mX5s$~IuC68)ixCco35Ub9w6tIthJ5qp&B(ob_kKJ*
zJw3h=P$(3>({;URVq$`DI7~DerMkMBa5zjb7$gt~5C{Ya27^Q*5kjF5&CSj1?d{3^
z{r%4^%lhV101436)|PTzw`Xi@jPmkwqR}YvcpOdB2m}H=di02afdL;Pr6d#z(bUvL
zI-SPzyq>D6s?@cBTrM|~N~Nf+ttAu+QBhHW5CSPBLj2h#Ap}AQA0nlst*wn@GKpar
zBi8~f%hJ2MyU{d_NF;&~0?+gCJnt{gMcY-o5Q6^xew0%BrvN1YN~wnW`g(%FpdWl-
zV89P>Wj1_3CX?~?`}gkyG~5J02ti3n2}&uHQh1){!#<UPQVQF)aU2KRw*Qgs-vNj3
z-o0z8tE<DdZG;fa&CU6>9vmD5V19lc$8k_fVVWkkZBr-|*xlVlDRp>l4?NFXSz21c
zG))SH0+wY_C=`6%bzNN7^=+nUVi*RNWnozsi;Ii6uDfzAKuVd(WHMy4Sq#G<pU-0$
zhA%}xKA-o+vMdb4U}tBCg@pxx%uTBzp=sK;ot>RMv$L~knue4TP1F272qFCb6j#Q@
z#RZd-lWc8mEd#wbP4aJ2%B`cLqpv=G{3zSo+x_Mh%VijbU!HtE&)L}-Gcz-+uC6-3
z*Fg5hRpGj>CWKht-Q6A8+}xD)_4SmMmHEMo^*%p8XM1~_>FH@+zkclidEiUn6!`hJ
zb)5iWLWpNl%ASW0AJWy;MPp+l00##Lyn6MDmoHxeECWx07r<wimpuWV06*OJ;3R-A
zfDu5yGDL^K%4I`OfFpp$#>Q<xynp{*0ydDm^t<&WZjh@!C+T$B?&#<+fZs36mblBO
zHvybYO-(6X*B#&tIKN9sF)K5jPTPq@!oF+3Rmd@*fF2+r?)Wd|>WzN|_ygF>@YIfg
RUN-;$002ovPDHLkV1jl}0RjL3

diff --git .idea/caches/gradle_models.ser .idea/caches/gradle_models.ser
index bec8a51c2296eb6e0985763d5c3b48ff663b43d4..6faecb511ccf6dafd0133796a1a83922bb0562f6
GIT binary patch
literal 140826
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

diff --git .idea/caches/build_file_checksums.ser .idea/caches/build_file_checksums.ser
index 813638178035fbb202c945946b6d0f366687f4a4..f203b8ad0617543e9607b30635c3e101e802fafe
GIT binary patch
literal 539
zc${1FmVvdnh`~NNKUXg?FQq6yGexf?KR>5fFEb@IQ7^qHF(oHeub?PDD>b=9F91S2
zm1gFoxMk*~I%lLNXBU^|7Q2L-Ts|(GuF1r}<i#MFTj`TnT;dMa8(f)}9Fm!vT3nKt
zTj0aMpIeEdv4nx&Co8cmQNOe#Ge_SyvB0{bfPsNA|LbM(=RkJ}g5>l-a(W(##Th_(
zR`y#54~r#SWM*J;W8likPfT%3OfJbU@?_vF$tX%K&dAS6sVJ~_U;qK0at<IV0K{xS
zi;7cAN;31(i=n<MEn;Abc3SgU{0AFH$O9$@29V7R0u$RWNgRKFIq$9LhGV@S6gW#5
zc#=T=h3P6}sAFIQDOCQvWzA|+%TL8KJg+>fIdr{*K_DkTIWY$mS_P>^C7G$k2*vK3
zPtAR1rQW?kM|`HU>JO<B1}**2;?$yI{hZR`jMTjJq<np-4f=>c$1vuKY|qVphD|Il
z8#rgY`QcPo!XSu8b(zeG^?HSE^=BJPt9P%qlmxmkv7kU7yLY4?i=Prm_WHFi<EC&A
IN6(=O0L_2D%m4rY

